# 第 5 章 容器运行时配置的担保要求

如前文 2.5 节所述，用于容器的所有安全性配置参数之中，除了那些用于处理集群管理和计划的以外，都是利用容器运行时提供的 API 设置的。尽管它们中的大多数涉及 Linux 内核特性（名称空间、Cgroups、能力）以及 Linux 内核模块，这些任务被包括在本章中，由于它们是由对 Linux 宿主 OS 接口进行系统调用的容器运行时执行的。本章的总体组织如下：

* (a) 5.2 节讨论了涉及 Linux 的名称空间特性的配置，它们为不同资源提供隔离
* (b) 5.3 节讨论了利用 Cgroups 特性的配置，它们主要用于设置资源限制，并且由此防止拒绝服务攻击
* (c) 5.4 节讨论了利用能力特性的配置，它们允许最小化权限的分配
* (d) 5.5 节讨论了用于设备隔离的配置，这可以通过利用 Cgroups 和内核可加载的基于标签的强制实施模块的组合来解决
* (e) 5.6 节讨论了那些可以在启动容器时进行设置，而非利用上述功能预先配置的参数

在分析这些功能之前，5.1 节概述了对于容器运行时本身的配置特性的需求。

## 5.1 对于安全连接的要求

容器运行时模块利用监听 Unix 套接字并且因此允许该运行时的远程管理的守护进程而实现。在特定情况下，管理组成员有可能将 Unix 套接字替换为 TCP 套接字 \[10\]。对此 TCP 套接字的任何连接都可能允许攻击者推送并且在高权限模式下运行任何容器，由此赋予它们对于宿主的 root 访问权限。TLS 连接的安全性担保要求涉及双方（容器运行时模块以及用于远程管理的客户端工具）在建立 TLS 会话之前对此连接的加密和认证。

## 5.2 对于基于隔离的配置的要求

### 5.2.1 容器进程隔离

对于容器而言，进程隔离是一项核心安全要求，以保证运行于不同容器以及宿主中的不同应用程序的完整性。容器环境中的进程隔离机制应该满足下列要求 \[4\]：

* (a) 能够将运行于不同容器中的进程彼此区分开来，以及将其同运行于宿主中的进程区分开来
* (b) 限制跨容器进程可视性
* (c) 防止特定类型的攻击，诸如：
    * (i) 运行于一个容器中的进程影响到运行于另一个容器中的进程，通过由 OS 提供的用于进程管理的接口（例如信号和中断）
    * (ii) 运行于一个容器中的进程直接访问属于运行于另一个容器中的进程的内存，通过特殊系统调用（例如 `ptrace()` 允许调试工具连接被调试的进程的内存）

为了提供进程隔离，用到了一项称为进程 ID（PID）名称空间的 Linux 内核特性。PID 名称空间是一种用于分组进程并且控制它们发现（例如通过 proc 伪文件系统）其他进程并且与其交互（例如发送信号）的能力的机制。PID 名称空间通过 `clone()` 或者 `unshare()` 系统调用来创建，并且与一个或者更多容器相关联。首个进程具有标识符 PID 1，后续进程的标识符按顺序增加。因此 PID 名称空间的特性还提供了 PID 虚拟化。位于不同 PID 名称空间中的两个进程可能拥有相同的 PID。

### 5.2.2 容器文件系统隔离

文件系统隔离的目标是防止从一个容器对另一个容器以及从任何容器对宿主的文件系统对象的非法访问。文件系统是一种 OS 接口，它允许进程存储和共享数据，以及在彼此之间进行交互。容器应用程序对数据的访问由它通过文件系统挂载点对文件系统的访问决定。因此，可以通过使得文件系统挂载点列表对于容器应用程序可见并且可访问来限制对数据的访问。这是通过挂载名称空间实现的。首先，一个命名的挂载名称空间随着一系列文件系统挂载点而被创建。此挂载名称空间随后与某一个只能在这些挂载点上发现并且发出诸如 `mount()` 或者 `unmount()` 的系统调用的进程相关联。它还可以操作位于该挂载名称空间中并且可通过这些挂载点访问的文件。下列内容为文件系统隔离安全性解决方案以及它们的限制：

* (a) 所有基于 Linux 的 OS 虚拟化解决方案使用一个允许容器和宿主之间的挂载隔离的 _挂载名称空间_，其目的是辅助对于用户和进程可见的环境的自定义。此特性不能保证容器之间的数据隔离。容器从其上一级继承文件系统挂载视图，并且能够访问文件系统的所有部分，即使每一个容器都是在一个新的挂载名称空间中创建的
* (b) 用于进程的文件系统访问封闭的典型解决方案是通过 `chroot()` 系统调用，它将某个进程绑定到文件系统层级结构中的树状子结构中，这允许容器同宿主分享资源，通过将其挂载到在容器中可见的树状子结构中。然而，此特性不能提供存在高权限进程（例如具有 `CAP_SYS_CHROOT` 权限的进程）的情况下的必要保护，这些进程可以绕过 chroot 的限制，由于 `chroot()` 系统调用只会影响路径解析这一事实
* (c) 对于文件系统对象的更好的保护可通过修改容器中的进程的 root 文件系统来提供，而非只是修改 root 目录（这是 `chroot()` 系统调用所允许的）\[4\]。这是通过 `pivot_root()` 系统调用启用的，它将旧的 root 文件系统的挂载点移动到新的 root 文件系统中的某个目录下，并且将新的 root 文件系统置于其中。这提供了文件系统层级的保护，由于旧的 root 文件系统可以被卸载，如果这是在容器的挂载名称空间中执行的，因此使得宿主的 root 文件系统对于容器中的进程不可访问
* (d) 另一种文件系统层级的保护策略是默认禁止某个限制区域中运行的进程挂载或者卸载文件系统，并且强制实施此权限的粒度控制，利用 `allow_mount*` 命令的选项
* (e) 另一种强化文件系统隔离的机制是为每一个容器指认一个独立的用户名称空间，这会将用户和组 ID 映射到宿主 UID 和组中的具有较少权限的范围中

由于上述每一种安全性解决方案的限制，对于文件系统的整体保护的担保要求涉及包括挂载名称空间、chroot、pivot\_root 和用户名称空间的配置的组合，以用于：

* 利用挂载名称空间隔离挂载点
* 利用 `chroot()` 为每一个进程更改 root 目录
* 利用 `pivot_root()` 为每一个进程更改 root 文件系统的可视性
* 利用用户名称空间限制用户访问范围

### 5.2.3 容器 IPC 隔离

容器的进程间通信（IPC）隔离意味着一个容器中的进程必须被限制为仅可在同一容器内部通过特定的 IPC 简单信道进行通讯。IPC 对象（或者与之相关联的机制）可以是基于文件系统的 IPC 对象或者并非基于文件系统的。基于文件系统的 IPC 对象，诸如域套接字或者命名管道，可以利用挂载名称空间和 pivot\_root 特性的组合来进行隔离（见上文 5.2.2 节），由于它们阻止进程访问其自身容器以外的文件系统路径。

然而，还存在其他 IPC 对象，诸如 System V IPC 对象、信号量集合（数组）、共享内存片断，以及消息队列等。在 Linux 中，这些 IPC 对象可以借助允许创建完全不相交的 IPC 对象集合的 IPC 名称空间而被隔离开来。每一个 IPC 名称空间拥有其自身的 System V IPC 标识符集合以及自身的 POSIX 消息队列文件系统。在一个 IPC 名称空间中创建的对象对属于该名称空间的成员的所有其他进程可见，而对于其他 IPC 名称空间的进程不可见。对于某一个进程可访问的 IPC 对象可以利用 `ipcs` 命令列出，或者利用 `ipcrm` 命令移除。

### 5.2.4 容器网络隔离

容器的网络层级的隔离通过网络名称空间特性而提供。对于所创建的每一个网络名称空间，一组网络设备、IP 地址、 IP 路由表、/proc/net 目录，以及端口号可以与之相关联。每一个容器可以拥有其自身的虚拟网络设备和应用程序以绑定到每一个名称空间的端口号空间。宿主系统中的适当的路由规则可以将网络数据包指引到与某个特定容器相关联的网络设备。因此可能拥有例如同一宿主系统上的多个容器化的网络服务器，其中每一个服务器都在其（每个容器的）网络名称空间中绑定到 80 端口。

网络连接性是运行于容器中的生产级应用程序，诸如网络应用程序和多层应用程序，的核心要求。容器可以通过一种称为覆盖网络的逻辑 IP 网络连接起来。容器平台（由容器、容器运行时、宿主 OS 和物理宿主构成）的典型网络配置涉及在容器宿主上创建网桥。宿主上的每一个容器都连接到该网桥。路由器在其混合模式中从其桥接接口捕获以太网数据包，被捕获的包通过用户数据报协议（UDP）转发到运行于其他容器宿主中的路由器端。这些 UDP “连接”是双工的，可以穿透防火墙，并且可以被加密 \[12\]。每一个容器通过第 2 层（链路层）虚拟网络接口（VNI）连接到该网桥，该接口具有有效的链路层地址或者用于第 3 层连接性的网络地址转换（NAT）。Linux 的第 2 层网络隔离基于网络名称空间的概念，这允许创建若干网络栈以便提供一种完全独立于容器的视图 \[4\]。

使用第 2 层 VNI 的网络隔离的最简单配置涉及定义一对虚拟连接以太网（veth）接口，其中一个接口被指认给与容器相同的网络名称空间，而另一个被指认给宿主名称空间。这两个接口之间的虚拟连接随后被建立起来，因此将容器同物理网络连接起来。有两种选项以启用这种连接 \[4\]：

* (a) 网桥设备：veth 接口和宿主物理接口通过虚拟网桥设备连接起来。在此选项中，所有容器和宿主接口被连接到同一链路层网桥，并且因此接收该网桥的所有链路层流量
* (b) 路由表：另一个选项是利用路由表在（容器所被连接到的）虚拟网络接口和（驻留于宿主上的）物理网络接口之间转发流量。在此选项中，只有当显式地提供了网络路由时，容器才能进行彼此之间的通讯

_安全性分析_：由这两种选项提供的网络隔离功能强制容器进程使用被指认的虚拟网段或者被指认的网络路由（例如通过 VPN 连接）。在这两种选项之间，路由表的使用相对于网桥设备解决方案提供了略高一些的安全性担保，由于后者允许容器地址对于连接到该网桥的所有容器可见。

为容器提供网络连接性的另一种方式是使用 MACVLAN 接口 \[13\]，它也允许每一个容器拥有其独立的链路层地址。虚拟以太网端口汇聚器（VEPA）是最广泛地应用于此类容器隔离选项的配置模式。然而，仅当基于名称空间的方式通过基于标签的访问控制以及同来自其他全局名称空间的进程进行隔离而得到加强时，才可能在进程层级对容器提供完整的网络隔离担保。

### 5.2.5 容器的用户和组层级的隔离

有些进程可能需要 root 权限的某个子集。用户名称空间特性可用于将某些用户 ID 的权限限制为该所需的子集。用户名称空间将用户和组 ID 号空间隔离开来。换言之，某个进程的用户和组 ID 在某个用户名称空间内外可以不同。在此，最为有趣的案例是，某个进程可以在某个用户名称空间以外拥有正常的低权限用户 ID，而同时在此名称空间内拥有用户 ID 0。这意味着此进程在此用户名称空间内拥有完整的 root 操作权限，而在此名称空间以外则只有低操作权限。

从 Linux 3.8 开始，低权限进程可以创建用户名称空间，这为应用程序的有趣的全新的可能性开辟了道路。由于在其他情况下的低权限进程现在可以在其用户名称空间内保持 root 权限，低权限应用程序现在可以拥有对于之前仅限于 root 的功能的访问权限 \[4\]。

## 5.3 对于资源限制解决方案的要求

在 Linux 容器环境中，应对拒绝服务攻击的主要保护机制是允许设置不同资源限制的 Cgroups 特性。“限制”规范特性不仅限制诸如 CPU、内存、存储等硬件资源，也适用于进程和任务。除了限制特性以外，Cgroups 允许指认一系列潜在的“资源消耗大户任务”，它们可以通过发送 SIGSTOP 信号被冻结，并且在随后发送 SIGCONT 信号而解冻 \[11\]。

除了其防止拒绝服务攻击的主要作用以外，Cgroups 特性还可以提供额外的网络层级保护，通过某种方法（利用网络分类 Cgroup）对网络数据包以某个“类标识符”的值进行标记。这随后可以被用作参数以过滤特定的包。（这个类标识符的值也可被用于基于服务质量（QoS）要求的优先级处理，尽管此特性属于性能增强而非严格属于安全性。）

下列表格提供了 Cgroups 特性能够对其设置资源限制或者访问控制的硬件资源列表：

> 表 1——利用 Cgroups 的 Linux 资源限制

|资源|“限制”特性或者访问控制|
|----|----|
|CPU|为一组进程指定 CPU 数量或者“CPU 份额”的值|
|内存|用于一组进程的“硬”和“软”内存分配单元|
|BLKIO|设置硬盘读写速度、每秒操作数、队列控制，以及由主要和次要数值所指认的等待时间；相对于文件系统的特定控制提供更多的粒度访问控制|
|设备|创建设备白名单，基于 (a) 类型（字符设备还是块设备）或者 (b) 主要和次要数值|

Cgroups 配置应该提供下列担保：

* (a) 它不应该暴露容器宿主信息，诸如通过 dmesg 暴露内核环缓冲，这可能协助内核漏洞利用或者信息泄漏
* (b) 它不应该允许本地硬盘访问，即使是在用户名称空间内通过原生硬盘、设备或者 make node（mknod）访问挂载受限的名称空间 \[11\]

## 5.4 对于容器的最小化权限配置的要求

如前文所提到的，Linux 的能力特性可用于分割 root 权限集合。所有容器运行时产品，诸如 LXC、Docker 以及 CoreOS Rkt，都带有默认配置文件，其中，容器的某些能力被启用而某些被禁用 \[11\]。由于运行于容器中的应用程序的权限需求，某些默认值必须被修改（即某些默认被启用的能力需要被禁用，而某些默认被禁用的能力需要被启用）。然而，对于托管于容器中的大多数应用程序，在配置 Linux 的能力特性时，下列担保要求必须被满足：

* (a) 提供权限以操纵非名称空间的内核参数（例如系统时间）的能力将会拥有该参数的效果，此参数的修改不仅是对于该容器，也是对于宿主和所有其他容器的。因此这样的能力（例如 `CAP_SYS_TIME`）不应该被启用
* (b) 提供几乎等同于 root 的宽泛权限集合的能力不应该被启用（例如 `CAP_SYS_ADMIN`）
* (c) 无需启用能力 `CAP_SYS_MODULE`，它允许加载和卸载内核模块，由于这会导致不安全的权限提升
* (d) 能力特性应该总是和用户名称空间配合使用，由于任何错误地启用某些能力而导致的进程权限提升将会被限制在名称空间内

## 5.5 对于设备隔离解决方案的要求

在 Linux 中，对设备的访问是通过设备结点实现的，设备结点是为宿主的设备驱动程序提供接口的特殊文件。设备结点同文件系统的剩余部分分隔开来，并且它们的结点被置于 /dev 目录中。这些结点对于名称空间并不警觉。设备结点的创建是通过 `udevd` 守护进程发出 `mknod` 系统调用而实现的。进程创建设备结点（用于访问块设备或者字符设备）的许可是由 `CAP_SYS_MKNOD` 能力提供的。如果对应的设备将要在容器之间或者不同容器与宿主之间共享，则容器被赋予对设备结点的访问。然而，设备结点是安全敏感的，由于它们将接口（特别是存储接口）暴露给运行于内核空间的代码，这可能被滥用以获得非法数据访问、权限提升或者挂载其他攻击。

在容器之间提供设备层级的隔离的一种可能的解决方案是使用“设备名称空间”，如果被引用的输入/输出（物理）设备是对于名称空间警觉的。不幸的是，很多 Linux 内核发行版并不支持设备名称空间特性。如果可用，此特性可用于为每一个容器创建虚拟设备，它们可以被多路传输以访问某个物理宿主设备。更进一步地，如果控制物理设备的 Linux 设备驱动程序对于名称空间并不警觉，并且这些设备假设只有一个控制它们的主控结点，对于它们的访问权限很难被安全地赋予低权限的容器，除非该设备只由单一容器专属使用。

在缺少设备名称空间的情况下，两种特性被用于控制容器对设备的访问。它们是：(a) 控制组，或者 Cgroups；以及 (b) 基于标签的访问控制。设备的 Cgroups 子系统被用于创建白名单，基于类型（即字符设备还是块设备）以及设备的主要和次要编号来针对设备格式化。通配符“all”适用于所有设备类型以及主要和次要编号，并且通常在显式地将设备列入白名单之前被用作默认的拒绝 \[11\]。

在 Linux 环境中有两种基于标签的强制执行方式：安全增强式 Linux（SELinux）和 AppArmor。在 SELinux 中，类别标签被应用于进程和数据/设备，并且进程对于资源的访问将会被拒绝，如果它不属于正确的分类。例如，某个特定的标签可以被应用于某个给定的容器 X，并且将要由该容器消费的数据被指认给相同的标签。由于指认类别过程的灵活性，SELinux 可以被用于强制实施精细粒度策略。AppArmor 是另一种基于标签的系统，它提供基于路径的访问控制（与 SELinux 中的文件系统结点相对）。对于特定应用程序、进程或者容器，限制条件可以被聚合起来以定义配置文件。所有这些基于标签的系统的共同的弱点在于，它们所提供的控制可以通过直接执行系统调用而被破坏。

因此，对于设备隔离解决方案的担保要求包括：

* (a) 所有容器必须被防止创建新的设备结点，并且 `CAP_SYS_MKNOD` 能力对于它们不应该被启用
* (b) 容器内的所有挂载点应该设置 nodev 标识（通过利用 `mount` 命令的 nodev 选项）以防止它们被用于创建文件以访问设备驱动程序
* (c) 所有容器应该仅被允许访问下列设备的集合，由于它们被表征为安全的 \[4\]，基于下列给出的观察：
    * _完全虚拟设备_——诸如伪终端和虚拟网络接口；此安全担保来自这些设备为每一个容器显式地创建并且未被共享这一事实
    * _无状态设备_——诸如 random、null 及其他；在所有容器之间共享这些设备的同时仍然能够保持宿主安全，由于它们是无状态的
    * _对于用户名称空间警觉的设备_——如果此设备（通过设备驱动程序代码）支持对于对应用户名称空间中的进程的验证能力，则这样的设备可以被安全地暴露给容器，由于特定的限制条件将会被强制实施
* (d) 如果 Cgroups 和基于标签的强制执行系统都被用于控制对设备的访问，应当谨慎以确保它们各自的规则不会产生冲突

## 5.6 对于容器启动选项的要求

每一种容器运行时产品都有带有众多参数的命令以启动容器。与此命令的安全使用相关联的担保要求被叙述为一组应该被避免使用的选项 \[4\]。作为最佳安全实践，容器不应该使用那些当它被启动时将会共享与容器宿主相关联的任何名称空间的选项 \[11\]。如若不然，这可能不仅允许容器查看与该名称空间相关联的资源/对象，而且允许操纵这些资源/对象，通过破坏由容器的名称空间的静态配置提供的隔离。下表提供了这样的名称空间的列表，对于它们而言，共享宿主侧的对应物不应该被用于容器启动选项。

> 表 2——禁止的容器启动选项

|名称空间/范例资源-对象|简述|安全威胁|
|----|----|----|
|Unix 分时系统（UTS）|所有容器被指认给其自身的 UTS 名称空间，因此无需获知宿主的 UTS 名称空间|容器中的进程可以看到并且操作宿主的主机名和域|
|IPC/共享内存片断|应用程序模块之间的用于进程间通信的共享内存片断被设置以用于快速通讯，由于它们比 REST API 调用更快|容器中的进程可以看到并且操作宿主的 IPC 对象|
|文件系统|宿主敏感的目录不应该以读写模式挂载为容器卷|赋予容器修改这些目录中的文件的能力，带有潜在破坏宿主安全的风险|
|在容器启动命令中设置 `net=host`|容器的网络模式不应该被设置为等同于宿主|这将会赋予容器只有宿主才应该拥有的权限（例如关闭其自身）或者访问只有宿主才需要访问的网络服务的权限|
|将容器端口公开至宿主|这被用于设置出入该容器的通讯|公开所有接口的默认选项不应该被使用；通过显式指定端口应该被绑定到的接口，出入该容器的流量被限制在给定的接口|
|容器间通讯|如果存在，此选项允许任何类型的容器间通讯，它必须不能被启用；与之相反，在两个需要通讯的容器之间必须显式设置通讯信道|任何被攻击的容器可以攻击宿主上的任何其他容器|

除了涉及同宿主共享的对象的容器启动选项以外，有一些专门适用于容器的参数应该在容器启动时被设置：

* (a) 容器应该总是被启动为具有一定的内存限制，以防止拒绝服务攻击，或是某些应用程序泄漏内存，以至于它最终将会消耗宿主的全部内存
* (b) 容器应该总是通过指定 CPU 份额数值而启动。默认值（总 CPU 数/容器数）可能对于某些容器并不够用，导致拒绝服务。指认给某一容器的 CPU 份额数值应该使得没有容器可以导致具有默认设置的其他容器得不到足够的资源。更进一步地，如果存在这样一组容器，其在 CPU 使用上相对于其他容器占据主导地位，则较低的默认值应该被指认给该组中的容器，以保证 CPU 份额的公平分配
* (c) 如果宿主 OS Linux 发行版支持某种基于标签的系统（例如 SELinux），则应该设置策略模板。容器引擎应该被启动为带有选项以识别该模板，并且容器启动 API 应该拥有选项以识别此策略模板参数，并且将其作为启动参数的一部分而包括进来
* (d) 容器应该被启动为仅有“必要的”能力，通过在初始时放弃所有能力，并且随后仅添加必要的能力。下列能力通常不应该存在于容器配置中（即 `NET_ADMIN`、`SYS_ADMIN`、`SYS_MODULE`），由于它们提供了超出大多数部署所必要的权限

