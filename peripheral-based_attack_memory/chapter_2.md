# 第 2 章 技术背景、预备知识和假设

> 在孩子面前放一台计算机并且指望由它来教育他，就好比在他的枕头底下放一本书，只不过更加昂贵而已。——Joseph Weizenbaum，德国/美国计算机科学家

为了理解我们的后续章节，尽管获知大量关于现代计算机架构的细节是有益的，然而在这里解释所有这些晦涩的细节并不现实。因此，我们将读者引向一系列文献 \[参见 54，59，118，127\] 以获得关于此话题的完整论述。我们将本章限定为理解本工作所必需的最重要的术语。我们从 _rootkit 进化_ 开始。这段进化史突出展示了为何呈现于后续各节的技术背景有助于理解本工作。

## 2.1 rootkit 进化

在流行的 x86 平台上，rootkit 的能力与其执行环境强烈相关，例如用户模式（3 环）或者内核模式（0 环）。现代 x86 处理器提供所谓的保护环以区分不同权限的执行环境，参见图 2.1。对 rootkit 进化的分析揭示了这一事实，即攻击者在 x86 平台发现了新的、更加强大的执行环境。以下段落总结了不同类型的 rootkit，即用户模式、内核模式、基于虚拟机的、系统管理模式、基于固件的以及基于外设的。这段概述呈现了 rootkit 进化史，并且展示了近年来 rootkit 这一术语是如何变化的。

> 图 2.1 “-3 环”环境，与 x86 平台上的其他 rootkit 环境相比

> 请注意，3 环和 0 环实现于硬件（宿主 CPU）中。术语“-1 环”、“-2 环”和“-3 环”被用于强调对应的执行环境的能力，它们并非实现于硬件中。

_用户模式 rootkit_ 使用简单的技术，其基本理念是将 rootkit 伪装成正常的软件 \[129\]。例如，攻击者向某个运行于用户模式并且具有超级用户/_root_ 权限的普通软件工具中添加所需的恶意功能。此修改过的工具替换了目标平台上的原始工具。用户模式 rootkit 被认为是 rootkit 进化的起点。其名称来源于赋予了超级用户 root 的权限级别。用户模式 rootkit 可以被运行于内核模式的特定检测工具发现。

_内核模式 rootkit_ 基于某种高级技术以便利用操作系统内核组件来隐藏 rootkit \[60\]。内核模式 rootkit 修改了内核，或者更准确地说，修改了内核代码（例如系统调用）或者内核数据。对内核的修改改变了内核行为以强制实施某些隐形能力，进而隐藏恶意活动 \[参见 129\]，例如击键码记录器。执行于内核模式的 rootkit 不受那些用于揭示用户模式 rootkit 的技术的影响。

用于控制一台计算机系统的更加强大的 rootkit 称为 _基于虚拟机的 rootkit_（VMBR），诸如 _SubVirt_ \[77\] 和 _Blue Pill_ \[108\]。一种称为 hypervisor 或者 _虚拟机监视器_（VMM）的控制实例通常被用于在 _虚拟机_（VM）中托管客户操作系统。而 VMBR 通过利用 VMM 环境以便在虚拟机中托管目标计算机的操作系统。由于操作系统内核执行于 VMM 环境上，VMBR 可以被看作运行于“-1 环”上。因此，一个恶意控制实例被放置于硬件和操作系统之间。VMBR 难于安装，然而反过来说，VMBR 同样难于检测。Blue Pill 可以在计算机运行时托管目标操作系统，即无需关机或者重启。

用于 rootkit 的另一种强大的执行环境称为 _系统管理模式_（SMM）。SMM 是一种特殊的高权限处理器模式，它用于执行特殊的系统软件。它同样可以被利用以实现所谓的基于 SMM 的 rootkit。在 SMM 中执行的代码运行于宿主 CPU 的最高权限上。这意味着基于 SMM 的 rootkit 在运行时具有多于操作系统内核和虚拟机监视器的权限。因此，基于 SMM 的 rootkit 可以被看作执行于“-2 环” \[145\]。在 2008 年，Embleton 等人 \[49\] 和 Wecherowski \[144\] 展示了 SMM 可以如何被用于 rootkit。SMM 代码存储于固件中，即 SMM rootkit 可以被看作固件 rootkit 的特例。

基于固件的 rootkit 也是非常强大的。在固件中部署 rootkit 非常困难，但是并非不可能。固件是一种存储于闪存存储器上的特殊低级软件。_基本输入/输出系统_（BIOS）是存储于 x86 平台上的闪存存储器中的固件的一个范例。基于固件的 rootkit 并不是部署于硬盘上。因此，很难检测并且移除此恶意软件。攻击者可以利用此 rootkit 来攻击操作系统，即使用户重装操作系统。Heasman \[56\] 在 Black Hat Federal 2006 大会上展示了如何实现并且检测基于 BIOS 的 rootkit。Heasman \[57\] 延续了此项研究。由 Wojtczuk 和 Tereshkin \[149\]、Loukas K \[84，85\]，以及 Ortega 和 Sacco \[97，98\] 等人展示其他 BIOS 固件攻击可以作为 rootkit 的基础。Brossard \[21，22\] 还展示了 _硬件后门是可行的_。此作者利用了开源 BIOS coreboot \[脚注 3\] 及其相关工具以刷新 BIOS 以及外设的只读内存以攻击计算机平台。

> 脚注 3：参见 [http://www.coreboot.org/Welcome_to_coreboot](http://www.coreboot.org/Welcome_to_coreboot) \[访问于 2014 年二月 25 日\]

隐藏于固件中的 rootkit 也可以被实现为使用平台外设的固件。这样的 rootkit 称为 _基于外设的 rootkit_。一种潜在地可被利用的外设是网卡 \[134\]。Heasman \[55\] 也讨论了如何实现并且检测一种部署于存在于 _外设元件互连标准_（PCI）设备上的扩展 _只读内存_（ROM）中的基于 PCI 的 rootkit。外设同实际的宿主系统之间被良好地隔离。因此，这种外设中的执行环境并未被反病毒软件所考虑。这使得外设对于攻击者而言极具吸引力，参见图 2.2。

> 图 2.2 能够潜在地被 rootkit 利用的专用隔离硬件概述

> 隐藏于外设中的 rootkit 能够直接访问计算机平台的主内存。因此，它们可以偷取敏感数据，诸如硬盘加密密钥、视频电话通讯会话密钥、在线银行凭证、口令、打开的文件等。这样的 rootkit 也可能修改主内存中的数据。

一种能够在独立处理器上执行平台管理代码的特殊微控制器提供了良好的隐形能力，并且同样可以被用于 rootkit。在 Black Hat USA 2009 大会上，Tereshkin 和 Wojtczuk \[131\] 展示了将此类微控制器用于 rootkit 的理念。他们引入了术语“-3 环”以强调其隐形能力。这样的基于外设的 rootkit 被认为比基于 SMM 的 rootkit 更具隐秘性。Bulygin \[25\] 展示了如何利用这种特殊的基于微控制器的环境来检测基于 SMM 和基于 VMM 的 rootkit。由于诸如网卡等外设通过主内存同宿主操作系统进行通讯，基于外设的 rootkit 可以通过非法读取或者写入宿主内存来攻击宿主。这种允许外设进行内存访问的机制称为 _直接内存访问_（DMA，参见 2.4 节）。由于这种机制，基于外设的 rootkit 被认为是绝对隐秘并且不可能被检测到的。这样的 rootkit 技术是本工作关注的焦点。基于外设的 rootkit 可以通过 DMA 访问宿主内存以偷取存在于宿主运行时内存中的口令、在线银行凭证、打开的文件等。它们还可以通过诸如基于内核的后门等其他攻击代码来渗透宿主 \[47\]。

注意，我们在本工作中避免使用术语“-3 环”。并没有什么“-3 环”是实现于硬件中的。诸如“-1 环”、“-2 环”和“-3 环”等术语仅仅被用于描述 x86 平台上的对应环境的权限级别。所处的环越低，则 rootkit 的能力就越大。在本论文中，我们将会使用术语“恶意软件”，由于我们所分析的攻击并非执行于宿主 CPU 上。因此，root 权限与之无关。我们所关注的恶意软件同原始的用户空间 rootkit 相比只有这一点是共同的，即它们的目标都是隐秘运作。

## 2.2 典型的基于 x86 的系统架构

典型的 x86 系统架构的主要组件描述于图 2.3 中。_中央处理器_（CPU）、_内存控制器集线器_（MCH）和 _输入/输出路径控制器_（ICH）之间的连接称为芯片组 \[54\]。这种芯片组解决方案也称为 _三芯片解决方案_。系统内存（_随机访问存储器_，或者简称为 RAM）以及显示适配器被连接到 MCH。MCH 控制了对内存的访问。它可以阻止对内存地址的请求，或者将此请求重定向到 ICH，如果该目标地址属于 ICH。诸如闪存存储器、_网卡_（NIC）等通过 _外设元件高速互连标准_（PCIe \[24\]）整合到系统中。此标准为外设和芯片组之间实现了一种串行互连。网卡和其他扩展卡可以通过 PCIe 连接到 ICH。用于存储诸如 _基本输入/输出系统_（BIOS \[参见 54，p.369\]）等固件的闪存存储器也被连接到 ICH。

> 图 2.3 x86 芯片组和外设组件

> 芯片组组件包括 _中央处理器_（CPU 或者宿主处理器）、_内存控制器集线器_（MCH，又称为北桥）以及 _输入/输出路径控制器_（ICH，又称为南桥）。外设不属于主芯片组。

请注意，Intel 在 _Intel 5 系列芯片组_ \[121，p.15\] 中引入了一种所谓的 _双芯片解决方案_。这意味着 MCH 功能被整合进宿主 CPU，并且被称为 _集成内存控制器_（IMC \[32，p.14\]）。同之前的 MCH 一样，IMC 是控制内存访问的控制实例。ICH 被更名为 _平台路径控制器_（PCH \[68\]）。本论文中引导的实验基于三芯片解决方案。

其他控制器设备将其他格式通过 PCIe 连接到系统，诸如 _通用串行总线_（USB \[8\]）、_火线_（FW \[6\]）或者 _串行高技术配置_（SATA \[7\]）等。传统 PCI 设备通过一种所谓的 _PCI 到 PCIe 桥接_ 连接到 PCIe 架构 \[24\]。在笔记本计算机中，_个人计算机存储卡国际联盟_（PCMCIA）/_快速卡_（ExpressCard）\[139\] 设备通过 PCIe 整合到系统中。宿主 CPU 不一定是系统中唯一的处理器。例如，显卡支持一种 _图形处理器_（GPU）以高效渲染计算机图形。待处理的数据存储于 _显存_（VRAM）中，它独立于通常的系统内存。具有相似属性的其他设备包括网卡以及位于平台的 MCH 中的 _Intel 管理引擎_（ME \[79\]）。它们同样利用独立处理器和独立内存来执行固件。

## 2.3 基于 Intel x86 的宿主中央处理器

Intel x86 _中央处理器_（CPU）公布于 1978 年 \[参见 59，附录 K.3\]。此后，x86 CPU 持续被增强，直到最近，x86 处理器包含若干个单元以支持用于不同计算任务的适当特性。现代扩展包括浮点单元、_单指令流多数据流_（SIMD \[117，p.524\]）、_流式 SIMD 扩展_（SSE \[117，p.748\]）、x64 \[58，p.351\]、_物理地址扩展_（PAE \[69，p.2-23\]）、多级缓存（L1、L2、L3 缓存 \[59，p.117\]）、_性能监视单元_（PMU \[参见 104，p.429\]），以及虚拟化的硬件支持等，如 Grawrock 所描述 \[54\]。一块现代 x86 处理器通常也包括多个核心 \[参见 59，p.117\]，这些核心提供具有不同的位大小的寄存器，即从 16 位到 512 位 \[参见 70，第 1.2.1 节\]。

为了提供保护机制，CPU 通过所谓的保护模式支持一种权限模型。此模型提供的不同权限等级也称为环，以分隔运行于此硬件上的特定软件。如果处理器处于保护模式，则有 4 种环可用。0 环是权限最高的环，而 3 环的权限最少。操作系统执行于 0 环。因此它同运行于 3 环的应用程序相隔离。1 环被认为是用于设备驱动程序的，而 2 环被用于服务，尽管在实践上 1 环和 2 环并未被使用 \[54，p.41\]。

_系统管理模式_（SMM \[69\]）是另一种处理器模式，仅对于系统固件可用。此模式被引入 x86 架构以实现高级能效，例如通过关闭未使用的硬盘，以及控制系统硬件，例如当系统达到温度限制时打开系统风扇并且关闭系统。SMM 通过中断触发，即 _系统管理中断_（SMI）。SMI 处理程序代码在系统初始化的早期由 BIOS 从闪存存储器中加载至 _系统管理内存_（SMRAM）。为了防止由来自除了 SMM 以外的其他处理器模式的代码修改 SMI 处理程序代码，芯片组提供了一个特殊的位，它称为 `D_LCK`。此 `D_LCK` 位在 SMI 代码被加载至 SMRAM 之后被设置以对其进行保护。如果此 `D_LCK` 位被设置，则不可能更改 SMRAM 的内容。

如果某个 SMI 触发了 SMM，当前执行的程序被中断，并且处理器状态将会被保存。随后，处理器执行 SMI 处理程序代码。当此处理程序代码执行完毕时，被保存的处理器状态将被恢复。当处理器从 SMM 切换回之前的处理器模式时，被中断的程序可以继续运行。注意，之前的处理器模式损失了 CPU 周期/时间，由于两种处理器模式不能同时被执行。SMM 可以被看作一种独立的执行环境。SMRAM 是一块独立的地址空间，并且仅在处理器处于 SMM 时可访问。换言之，操作系统不能访问 SMRAM。更进一步地，SMM 中的权限不受限制，执行于 SMM 中的代码可以调用任何 I/O 以及系统指令。

在 Intel 平台上，x86 中的硬件虚拟化扩展称为 _Intel 虚拟化技术_（Intel VT）\[54\]。虚拟化机制被用于在单一的硬件平台上并行运行彼此隔离的多个操作系统或者应用程序。一种称为 _虚拟机监视器_（VMM）的控制实例用于托管 _虚拟机_（VM）中的客户操作系统。现代 x86 CPU 提供了一种特殊的指令集，称为 VT-x。VT-x 是 Intel VT 的一部分，并且其本意是用于支持硬件虚拟化。此种硬件支持提供了两种特殊的 CPU 操作：VMX root 操作和 VMX 非 root 操作。VMM 运行于 VMX root 操作模式。运行于 VMM 之上的 VM 处于由 VMM 控制的 VMX 非 root 模式。这两种操作模式都支持其各自的保护环，各 4 个。因此，客户系统的软件（内核、驱动程序、应用程序等）可以运行于其被指认的权限级别。VMX 非 root 操作模式中的保护环被认为是低权限的，由于这些环受到运行于 VMX root 操作模式的 VMM 的控制。而 VMX root 操作模式的 4 个环是高权限的。通常，VMM 只会使用最高权限的环。此环通常称为“-1 环”以强调它控制着较低权限的 0-3 环这一事实。

x86 微架构还实施了这样一种流水线概念，它具有诸如分支预测和乱序执行等特别执行优化特性 \[118，p.329ff\] \[127，p93ff\]。执行流水线利用微运算进行工作，即运算被作为程式化原子单元而实现。Intel 架构指令被翻译为微运算 \[118，p.331\]。对于乱序执行，需要一块所谓的 _重排序缓冲区_（ROB \[118，p.333\]）来跟踪重命名的寄存器。寄存器重命名发生于乱序执行过程中。微运算中所使用的寄存器通过 _寄存器别名表_（RAT \[118，p.333\]）而被重命名，它也被称为 _寄存器分配表_（RAT \[参见 127，p.100\]）。

PMU 以 _模型特定寄存器_（MSR \[69，第 9.4 节\]）的形式实现，它允许软件开发者对微架构相关的事件进行计数。这有助于程序员编写针对某一 CPU 微架构优化的代码 \[104\]。例如，MSR 可以被配置为计数在代码执行时发生的缓存未命中、RAT 停止，以及分支预测错误等 \[69，第 18/19 章\]。用于事件计数的 PMU 寄存器也称为 _性能计数器_ 或者 _硬件性能计数器_（HPC）。它们仅在 0 环中可用。与性能测定相关的另一种特殊目的寄存器是所谓的 _时间戳计数器_（TSC \[69，第 17.12 节\]）寄存器。TSC 寄存器可以在平台重置之后被用于计数 CPU 周期。由不同的权限级别对时间戳计数器寄存器和性能监视单元寄存器的访问可以由 x86 控制寄存器 4（`CR4`）\[参见 69，第 2 章\] 来控制。

一种同外设交换数据的特殊输入/输出（I/O）特性是经过由 x86 CPU 提供端口（I/O 端口 \[117，p.70，341\]）的 I/O 映射 I/O 的概念。此概念与内存映射 I/O（同样由 x86 系统提供 \[117，p.343\]）互补，在后者的情况下，外设的内存和寄存器都被映射到宿主 CPU 的内存地址空间。外设同样会通过中断与宿主 CPU 通讯，以发出例如新数据可用的信号 \[117，p.252\]。为了同宿主系统进行通讯，外设也可利用直接内存访问的概念。在此情况下，外设并不直接同宿主 CPU 通讯，参见 2.4 节。

## 2.4 直接内存访问

PCIe 支持用于外设，或者更准确地说，诸如显卡、网卡以及管理控制器等专用硬件的 _直接内存访问_（DMA）。DMA 允许快速内存访问而无需宿主 CPU 的介入。DMA 的目的在于从宿主 CPU 移除负载。DMA 允许外设绕过 CPU 获得对全部宿主内存的访问。CPU 可以在 DMA 传输发生时执行其他任务。外设可以拥有它们自己的引擎以执行 DMA。此类 DMA 称为第一方 DMA \[133，p.428\]。另一种机制称为第三方 DMA \[133，p.428\]，在此，需要由一个中央 _DMA 控制器_（DMAC，参见图 2.3）来为不带 DMA 引擎的传统设备（例如基于 _工业标准结构_（ISA \[116\]）格式的设备）提供快速内存访问。它也被集成到现代平台中 \[64，p.128\]。

> 图 2.4 第三方和第一方 DMA

> \(a\) 第三方 DMA：要求宿主 CPU (1) 通过 I/O 端口配置（源和目标地址）中央 DMA 控制器，以便 (2) 执行 DMA 传输。宿主 CPU 将会被 (3) 中断，如果 DMA 传输完成 \[31，p.454\]。因此，宿主 CPU 对于第三方 DMA 传输警觉。\(b\) 第一方 DMA：外设设备可以 (1) 配置其自身的 DMA 引擎。此设备作为总线主控（参见第 2.5 节）以获得对于系统总线的控制来执行 DMA 传输。此设备 _可以_ 中断宿主 CPU，如果该设备 (2) 完成传输。传输同样能够进行，如果此设备并不在 DMA 传输完成时中断宿主 CPU。在此情况下，CPU 对于 DMA 传输并不警觉。

图 2.4 高亮显示了第三方和第一方 DMA 之间与隐秘操作有关的一个重要区别。如果使用第三方 DMA，宿主 CPU 对于 DMA 传输警觉，由于外设需要宿主 CPU 通过 I/O 端口 \[脚注 4\]（参见 2.3 节）来配置 \[参见 31，p.454\] DMAC。如果使用第一方 DMA，宿主 CPU _不一定_对此传输警觉。注意，DMAC 或者 DMA 引擎只能访问宿主内存地址，而非诸如宿主 CPU 缓存、宿主 CPU 寄存器或者硬盘等。后一条规则提示从运行时内存中移出至硬盘中的数据对于 DMA 引擎来说也不可访问。

> 脚注 4：参见诸如 `arch/x86/include/asm/dma.h` 和 `arch/x86/include/asm/io.h` 等 Linux 源代码。

## 2.5 总线主控

计算机平台拥有若干种总线系统，例如 PCIe 和 _前端总线_（FSB）。因此，平台拥有取决于总线系统的不同的总线主控类型，参见图 2.5。总线主控是一种能够经过某种总线引发数据传输（例如从 I/O 设备到主内存）的设备 \[58，第 7.3 节\]。某个连接到总线的设备（CPU、I/O 控制器等）本质上并不是总线主控。此设备只是一个 _总线代理_ \[1，p.13\]。如果该总线必须被仲裁，则总线主控可以向仲裁器发送一段总线所有权请求 \[9，第 5 章\]。如果仲裁器将总线所有权授予该总线主控，则该总线主控可以引发数据传输，只要总线所有权被持续授予。注意，此过程与 PCIe 设备不相关，由于其点对点的属性。PCIe 请求不需要被仲裁，因此，总线所有权并非必需。此总线并未如同其在 PCIe 的前身 PCI 中那样被共享。

> 图 2.5 总线主控拓扑结构

> 总线主控通过不同的总线系统（例如 PCIe，FSB）访问内存。MCH 为不同的总线控制器仲裁主内存访问请求（基于 \[23，p.504\] \[24\] \[58，第 7.3 节\] \[63，第 1.3 节\] \[64\]）。

然而，PCIe 设备的总线主控能力是通过某个特定的位来控制的，它称为 _总线主控启用_（BME）。BME 位是该外设的标准配置寄存器的一部分，并且通常由执行于宿主 CPU 上的对应设备驱动程序来设置。MCH（位于 PCIe 的视野之外）仍然对从不同的总线接口到主内存的请求进行仲裁 \[63，p.27\]，参见图 2.5。宿主 CPU 也是一个总线主控，它通过 _前端总线_（FSB）从主内存中获取数据和指令。I/O 控制器（例如以太网、硬盘控制器等）为 I/O 设备（例如 USB 键盘/鼠标、硬盘、网卡等）提供独立的 DMA 引擎。这意味着如果外设对主内存的访问请求由 MCH 处理，则 PCIe 与之完全不相关。

## 2.6 输入/输出内存管理单元

Intel 引入了一种称为 _用于直接 I/O 的 Intel 虚拟化技术_（VT-d \[2\]）的技术作为若干构建块之一，以便为 x86 系统提供硬件支持的虚拟化。VT-d 可以被看作一种 _输入/输出内存管理单元_（I/OMMU）以便有效地辅助虚拟化要求，诸如对运行于同一虚拟机监视器上的不同虚拟机进行可靠的隔离。VT-d 的应用主要与虚拟化相关联。有了 VT-d，虚拟机监视器或者操作系统等可以创建内存保护域。例如，互相隔离的物理内存子集可以被指认给虚拟机或者 I/O 设备驱动程序的内存。未被指认一块保护域的 I/O 设备没有对该域的物理内存的访问权限。这些访问限制通过地址翻译器而实现。系统软件对由 Intel VT-d 提供的所谓 _DMA 重映射_（DMAR）引擎进行配置。这样的引擎将例如由 I/O 设备触发的内存请求映射到物理内存。VT-d 可以阻止内存请求，如果该设备未被指认保护域。请注意，激活的 I/OMMU 可以为宿主 CPU 引入显著的性能开销 \[13\] \[150\] \[88，p.129\]，其结果是此技术的使用经常被避免。

为了允许系统软件配置 DMAR 引擎，BIOS 需要将对应信息以 _高级配置与电源接口_（ACPI \[44\]）表的形式加载至主内存。系统软件可以利用这些信息（例如 DMAR 引擎数量）来设置保护域。请注意，在主内存中存储 ACPI 表这一做法带来了严重的安全威胁。这些表可以通过直接内存访问来访问，并且可以如同 Wojtczuk 等人 \[148\] 和 Sang 等人 \[111\] 所描述的那样被修改。负责正确配置 DMAR 引擎的系统软件可能会失效，如果此漏洞被攻击者所利用。

## 2.7 信任和对手/攻击模型

此攻击者模型提供了关于一种隐秘 DMA 攻击场景的描述。攻击者能够 _远程地_ 利用恶意负载来渗透存在于计算机平台中的专用硬件。这可以通过利用与操作系统或者固件相关联的零时差漏洞 \[例如参见 47\] 来实施。我们假设攻击者能够在运行时对目标平台进行攻击。这不仅可以通过远程利用固件漏洞来实现，也可以通过分别由 Duflot \[45\] 和 Triulzi \[135\] 所描述的远程固件更新机制来实现。除了上述远程利用以外，攻击者还能够在本应作为拥有者的实体获取并且在目标平台上部署外设之前渗透该外设。

此专用硬件支持如 2.4 节所述的第一方 DMA 并且通过内存总线访问主内存，如图 2.5 所示。我们假设目标计算机平台拥有通常的最新防御机制，诸如反病毒软件和宿主防火墙。此平台的用户并未应用诸如硬件防火墙等额外的硬件以保护此计算机平台。我们假设只有隐秘攻击可以算作成功的攻击。因此，攻击者想要利用专用硬件的隐形潜力以隐藏攻击。对于主内存的攻击（例如对于机密性和完整性的侵犯）只来自于外设并且是通过 DMA。攻击者并未实施这样一种要求外设和宿主之间进行协作以提高隐秘攻击成功率的攻击。我们进一步假设攻击者能够保证对完整性的侵犯（内存写访问）不会导致攻击的暴露。额外的硬件将会显著降低隐秘攻击的成功率。例如，最有可能的情况是攻击者致力于偷取数据以引导业界间谍活动或者获取在线银行凭证等。为了实现这一点，攻击者必须通过 DMA 从主内存中读取数据（对机密性的侵犯）或者向主内存中写入数据（对完整性的侵犯）。

我们将某个计算机平台视为可信的，如果它满足所应用的安全策略。这意味着在我们的案例中，没有基于 DMA 的恶意软件通过 DMA 读取或者写入平台的主内存来攻击宿主平台。我们依赖于一种最小化的 _可信计算基_（TCB \[37，p.66\] \[99，p.8\]），它包括宿主 CPU 和内存芯片硬件，以及它们之间的通讯路径（前端总线、内存控制器集线器、内存总线）。执行于宿主 CPU 上的软件（系统软件和应用软件）在平台被攻击之前处于可信状态。这意味着软件被正确地加载和启动，并且行为符合预期。我们并不依赖诸如 I/OMMU 等预防性地措施，由于 2.6 节所述的安全性问题。

