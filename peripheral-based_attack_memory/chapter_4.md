# 第 4 章 关于一种基于直接内存访问的隐秘恶意软件的研究

> 我们信仰上帝，我们监控所有其他人。——美国空军情报、监控和侦察机构之美国空军技术应用中心的座右铭

恶意软件开发者和反恶意软件社区之间的军备竞赛达到了一个新的水平。针对内核级别的 \[60\]、基于虚拟机监视器的 \[77\]，以及基于系统管理模式的恶意软件 \[49\] 的反制措施已经被提议出来 \[51，107，25\]。其结果是，研究者探索了新的环境以用于隐藏恶意软件。恶意软件可以被放置在诸如显卡和网卡等专用硬件上以攻击宿主平台 \[参见 134，135，47\]。除了其他组件以外，这些设备带来了一块专用的处理器和专用的运行时内存。这些设备可以独立于宿主系统而运作。反病毒软件不能检测存储于独立内存中并且执行于另一块处理器上的恶意软件。攻击者可以利用这些设备，或者更准确地说，利用其直接内存访问机制，通过直接攻击宿主运行时内存而绕过构建于操作系统中的保护机制。我们将这种执行有目标的基于 DMA 的隐秘攻击以定位并且读取或者修改目标数据的代码称为 _DMA 恶意软件_。这样的数据可能是用于加密硬盘的密码学密钥、在线银行帐户的凭证、即时通讯聊天会话，以及存在于文件缓存中的已经打开的文档等。

在本章中，我们将 DMA 攻击特征化，并且推导出术语 DMA 恶意软件。我们这样探索该术语，即通过检测 DMA 恶意软件是否能够在显著提升针对计算机平台发动隐秘攻击的成功率的同时保持高效性和有效性。为了进行此项评估，我们构建了自己的 DMA 恶意软件 DAGGER——一种基于 DMA 的击键码记录器（DmA-based keystroke loGGER），它将其所捕获的数据潜出至某个外部实体。我们对此 DMA 恶意软件的高效性、有效性，以及特别是隐秘性感兴趣。我们之所以选择实现一种击键码记录器，是为了显示“短寿命”数据也能够被 DMA 恶意软件所捕获。

我们的实现基于 Intel 管理引擎，它是流行的 x86 平台的一部分。Intel ME 被实现于商用以及消费级平台（参见 Intel 博锐平台 \[66\]）以支持不同的应用，诸如 _Intel 主动管理技术_（iAMT \[79\]）或者 _身份保护技术_（IPT \[67\]）。我们的 DMA 恶意软件 DAGGER 并非执行于宿主处理器上。它执行于由 Intel ME 提供的处理器上，并不需要额外的硬件。DAGGER 实现了对于用户输入的隔离的运行时攻击。此外，我们的 DMA 恶意软件能够偷取密码学密钥，在攻击中针对操作系统内核结构，以及从文件缓存中复制文件等。尽管 DMA 恶意软件不能被反病毒软件检测到，攻击者仍然面临某些挑战。DMA 恶意软件必须是有效的，即它应该能够成功攻击不同系统。DMA 恶意软件还必须是高效的，即运行得足够快以查找并且处理数据，即使是在处理虚拟内存地址以及随机放置的数据时。这样的恶意软件已经超出了利用 DMA 硬件的能力。

本章的主要贡献包括：

* **DMA 恶意软件定义**：有不同类型的代码用到 DMA。为了清楚地区分某段代码应该被看作无害、攻击，还是 DMA 恶意软件，我们引入了一种适当的定义。
* **DMA 恶意软件核心功能**：我们列举了一系列要求，它们是 DMA 恶意软件为了实施成功的攻击所必须满足的。
* **DMA 恶意软件原型实现的评估**：为了显示 DMA 恶意软件在增加隐秘攻击的成功率的同时保持了有效性和高效性，我们实现了 DAGGER。DAGGER 执行于隔离的 Intel ME 之上。DAGGER 能够隐秘地运作并且攻击多种操作系统。我们的实现是快速并且高效的，因此它可以在平台启动过程的早期捕获击键码。这使得 DAGGER 能够在 Linux 下捕获例如硬盘加密口令等。
* **DMA 副作用检测方法**：我们呈现了一种检测方法，它可以揭示执行于隔离硬件环境中的 DMA 恶意软件。我们的工作展示了 DMA 恶意软件能够造成非预期的副作用，而我们可以利用那些被广泛使用并且跨平台可用的 CPU 特性来检测它们。

## 4.1 DMA 恶意软件定义

为了定义 DMA 恶意软件这一术语，我们首先对不同类型的基于 DMA 的代码进行了特征化，这有助于清楚地区分简单的 DMA 应用、DMA 攻击以及 DMA 恶意软件，在此，后者明确地专注于隐秘性。注意，DMA 恶意软件超出了控制 DMA 引擎的能力以外。实现了恶意功能的基于 DMA 的代码被看作严重的威胁。这样的代码可以在渗透和运行时隐秘运作。例如对于长期攻击而言，如果代码能够在平台重启以及关机和待机模式下存活，这也是一种优势。因此，我们可以在评估利用 DMA 的代码时优先考虑下列判据。即该基于 DMA 的代码：

* (C1) 实施了恶意软件功能
* (C2) 不需要物理访问以增加隐秘渗透的成功率
* (C3) 在运行时应用了 rootkit/隐形能力
* (C4) 能够在重启/待机/关机模式下存活

我们将一种二进制体系用于我们的优先级：

|2<sup>3</sup>|2<sup>2</sup>|2<sup>1</sup>|2<sup>0</sup>|
|---|---|---|---|
|C1|C2|C3|C4|

此体系区分了 16 种基于 DMA 的代码。我们可以为每一种得出一个独特的数值。例如，某段基于 DMA 的代码并不实施恶意行为（`C1=0`），不会在宿主上留下痕迹（`C3=1`），不依赖物理访问（`C2=1`），并且不能在重启之后存活（`C4=0`），则它被映射到二进制结构 0110。此结构对应于十进制的第 6 类。所得出的数字越大，则该基于 DMA 的恶意代码越危险。

我们关于 DMA 恶意软件的定义如下：

> **定义**：DMA 恶意软件是执行于专用硬件之上，通过一种称为直接内存访问的机制攻击计算机系统，并且至少满足判据 C1、C2 和 C3 的恶意软件。

当其被应用于第 2 章所介绍的目标平台时，此定义意味着：该 DMA 恶意软件基于第一方 DMA，并且其 DMA 引擎可以被攻击代码配置为不涉及宿主 CPU。攻击代码执行于具有其自身的处理器和运行时内存的专用硬件之上，例如网卡。控制了网卡可以增加攻击者在潜出时隐藏数据的成功率。表 4.1 将我们的二进制体系应用到第 3 章“相关工作”所呈现的 DMA 攻击上。此表还描述了哪些相关工作根据我们的定义属于 DMA 恶意软件。在本章，我们同样致力于开发一种 DMA 恶意软件的概念验证，它至少满足判据 C1、C2 和 C3。

> 表 4.1 DMA 攻击范例对于判据 C1-C4 的满足情况

|攻击呈现于|`C1 C2 C3 C4`|DMA 恶意软件|
|:---:|---|:---:|
|\[90\]（USB）|`-  -  -  √`|-|
|\[43，42，17，101，19，18，15，87\]（火线）|`√  -  √  √`|-|
|\[11，61，87\]（PC 卡）|`√  -  √  √`|-|
|\[131\]（Intel ME）|`-  √  -  √`|-|
|\[35，36，47\]（网卡）|`√  √  √  √`|√|
|\[134，135\]（显卡和网卡）|`√  √  √  √`|√|
|\[80\]（显卡）|`√  √  -  -`|-|

> 注意，此评估基于公开可获得的材料。如果我们仅仅依靠可获得的资源不能确定某个判据是否满足，我们假设该判据被满足。

## 4.2 DMA 恶意软件核心功能

在攻击宿主时，攻击者仅仅控制 DMA 引擎并不够。此引擎允许攻击者读取和写入宿主内存。然而，在大多数情况下，目标内存地址未知。本节描述了 DMA 恶意软件的核心功能，即克服地址随机化、内存映射，以及搜索空间限制。

攻击者必须确定内存地址。然而问题在于，例如分配给内核数据结构的内存空间在平台重启之后并不一定是位于原来的内存地址。数据结构被操作系统 _随机放置于内存中_。这可以以某种自然的方式发生，例如，当某个驱动程序分配内存并且获取下一段未分配的可用内存块时。该块的内存地址在平台重启之后不一定与原来相同。或者，操作系统可以应用某种随机化算法以保证数据结构不会被放置于相同的内存位置。当然，攻击者可以扫描全部系统内存以查找目标数据的签名。但是这对于扫描一台具有 4 GiB 或者更多的物理内存的系统来说非常低效。

操作系统利用 _虚拟内存地址_ \[参见 31，第 15 章\] 进行工作，而 DMA 则利用 _物理内存地址_ 进行工作。操作系统创建了所谓的页表，它们被宿主 CPU 用于将虚拟内存地址映射到物理内存地址。这种映射在利用 DMA 解析内存地址指针时绝对必要。一种称为 `CR3` 的特殊宿主处理器控制寄存器包含页表的物理内存地址。攻击者不能访问 `CR3` 寄存器。DMA 引擎的可视性被限制在宿主内存以内。如果不进行深入分析，攻击者就必须扫描全部内存地址空间以查找相关数据。有两种潜在的方式使得攻击者可以克服这一困难。第一种方法是分析操作系统是否将上述数据结构放置在近似相同的内存区域。第二种可能性是实现操作系统的内存管理机制，即攻击者必须找到某种方式以访问由操作系统创建的内存页表。只要有了对页表的访问，攻击者就可以遍历页表并且由此解析由一个数据结构指向另一个数据结构的指针。这仍然需要已知的起始点用于搜索。

## 4.3 DAGGER 的设计和实现

我们将会在下一小节呈现我们的基于 DMA 的击键码记录器 DAGGER 的一般设计的概述，然后我们在 4.3.2 节解释 DAGGER 的实现细节。

### 4.3.1 一般设计

我们的 DAGGER 设计如图 4.1 所示。DAGGER 是一种 DMA 恶意软件。即 DAGGER 必须至少满足 DMA 恶意软件定义中的判据 C1、C2 和 C3。DAGGER 包含 3 个主要的组件：

* **搜索**：通过 DMA 在宿主内存中查找有价值数据的地址。
* **处理数据**：在搜索过程中识别的区域内读取有价值数据。
* **潜出**：以某种宿主不可见的方式潜出信息。

> 图 4.1 DAGGER 一般设计

> DAGGER 执行于具有 DMA 能力的设备上，于是它可以从宿主运行时内存中 (1) 搜索并且 (2) 处理数据。它控制了某一通讯路径以潜出数据 (3)。

### 4.3.2 基于 Intel ME 环境的实现

为了评估 DMA 恶意软件，我们选择在 Intel ME 上实现 DAGGER。Intel ME 为实现我们于下文所述的 DMA 恶意软件提供了某些有用的特性。

Intel ME 的核心是一块植入于平台 MCH 中的嵌入式微控制器。此隔离环境包含 _只读存储器_（ROM）、_静态随机访问存储器_（SRAM）、用于访问宿主内存的 DMA 硬件 \[25，131\]，以及一块处理器，如图 4.2 所示。ME 的嵌入式处理器是一块 ARCtangent-A4（ARC4）处理器。此隔离环境持续可用，与电源状态无关，甚至在待机或者开关机状态下仍然可用。它只要求芯片组被连接到某个电源。执行于此嵌入式微控制器上的应用程序被实现为固件（ME FW）的形式，并且与 BIOS 共同存储于闪存存储器中。最重要的 ME 固件范例是 _Intel 主动管理技术_。然而取决于计算机平台的种类（商用或者消费级），ME 还可以运行其他固件。例如由 Intel ME 执行的其他固件包括 _Intel 身份保护技术_、_报警标准格式_ \[131，p.46\]、用于温度和风扇控制的 _Intel 安静系统技术_（QST \[131，p.46\]），以及 _集成可信平台模块_（iTPM \[79，p.109\]）。

> 图 4.2 Intel 管理引擎环境

> Intel 管理引擎（ME）环境包括 MCH 中的管理引擎。更进一步地，此环境包括一部分隔离的内存以及一部分隔离的持久性闪存处理器。ICH 同样包含 ME 环境组件，特别是用于实现带外通讯的组件。

ME 固件可以通过一个称为 _ME 接口_（MEI \[79，p.71\]）的 PCI 设备同宿主进行通讯。例如，MEI 可以提供所执行的 ME 固件的版本。ME 环境提供了额外的 PCI 设备 \[脚注 10\] 以支持诸如文本控制台和硬盘重定向等某些 AMT 特性。一个串口被模拟为实现文本控制台重定向 \[参见 79，第 5 章\]。发送至此端口的文本输出被通过网络转发至远程控制台。有了这项能力，管理员可以远程控制 BIOS。为了实现硬盘重定向，一块本地硬盘被 ME 环境模拟 \[参见 79，第 5 章\]。管理员可以通过本地模拟硬盘远程挂载存储介质（例如一张含有操作系统安装程序的 CDROM 以恢复此启用了 AMT 的平台上的操作系统）。

> 脚注 10：这些设备可以作为总线主控，参见 2.5 节。

在平台加电过程中，ME 固件镜像被加载至 ME 内存。ME 固件本身运行于微控制器内部的 ARC4 处理器上，它还会使用某些系统内存，如图 4.2 所示，以存储运行时数据。此运行时内存由某一内存区域提供，并且对于主 CPU 和操作系统不可见。这种隔离由芯片组强制实施 \[79\]。

ME 环境引入了 _带外_（OOB）通讯，即由 iAMT 使用的特殊网络流量信道。启用了 iAMT 的计算机平台由远程管理控制台通过 OOB 管理。OOB 同样持续可用，而与电源状态无关。OOB 可以看作运行于相同硬件上的隔离网络连接。ICH 实现了必要组件以便为 ME 环境提供 OOB 特性。固件将专门用于例如 iAMT 的网络流量过滤出来并且将这些数据包重定向至 ME。宿主对于重定向的 ME 网络流量并不警觉。此类流量由 TCP 端口号来识别。

### 4.3.3 针对 Linux 和 Windows 目标的攻击实现细节

我们实现了两种击键码记录器原型以攻击两类目标，即基于 Linux 和 Windows 的操作系统。我们决定查找并且监控目标操作系统的 32 位版本的键盘缓冲区地址。与 64 位版本相比，32 位版本必须处理更加复杂的内存管理，例如，攻击者在映射内存地址时必须考虑 _物理地址扩展_（PAE \[105，p.769\]）或者某些内存偏移量。在下一小节中，我们描述了我们是如何实现如 4.2 节所述的 DMA 恶意软件核心功能的。这些原型在其 _监控阶段_ 捕获短寿命的击键码。每种原型以不同方式处理用于不同目标缓冲区的 _搜索阶段_。这是由至少两大原因决定的。原因之一是为了评估 DMA 恶意软件的尽可能多的方面。另一个原因是不同的操作系统拥有不同的内存管理属性。我们使用一种由 Tereshkin 和 Wojtczuk \[131\] 所描述的漏洞以便在运行时渗透 ME 环境。为了调用我们的代码，我们挂钩到某个被我们识别为库函数 `memset` 的 ME 固件函数上。Tereshkin 和 Wojtczuk \[131\] 假设他们挂钩了某个计时器中断处理程序，但是他们实际上挂钩了 ME 固件函数 `memcpy`。我们之所以选择挂钩 `memset` 是由于我们确定此函数被更加频繁地调用。

我们的 Linux 变体基于如图 4.3 所示的签名扫描。我们分析了可获得的 Linux 源代码以得出我们的目标的签名，即键盘缓冲区的物理地址。此缓冲区地址是 _USB 请求块_（URB）结构的一部分，该结构定义于 Linux 源代码的 `include/linux/usb.h` 文件中。所需的结构字段称为 `transfer_dma`。此内存偏移量随内核版本不同而不同。我们通过利用 _多重启动管理器_（GRUB）来解决这个问题，使其在固定的物理内存地址放置一个标识符。我们实现了一个函数以便通过 DMA 读取该标识符并且对内核版本号进行分析以得出对应的偏移量。随后，我们的原型进入搜索阶段，即签名扫描。

> 图 4.3 USB 请求块签名扫描（简化）

> \(1\) 开始查找指向 USB 设备结构的指针，这样的候选指针对齐到 `0x400` 边界。结构字段 `transfer_dma` 的值必须对齐到 `0x20` 边界。如果这两个条件同时为真，此 USB 设备结构中的产品字符串将被 (2) 检查是否包含子字符串"USB"和"Keyboard"。在签名扫描的最后一步 (3) 检查键盘缓冲区是否包含 _垃圾信息_，即无效的击键码。

由于我们的 Linux 原型针对的是内核数据结构，我们可以将搜索空间限制为系统内存的最前面 1 GiB。标准 Linux 系统拥有一种 1 GiB / 3 GiB 的内存分割方案，即 1 GiB 用于内核空间，3 GiB 用于用户空间。我们能够通过经验性地分析内核将我们的签名搜索所需的数据结构放置于哪块内存区域来进一步限制搜索空间。我们已经确定对于 Ubuntu Linux 内核版本 3.0.0 在一次新鲜的平台重启之后，该内存区域介于 `0x33000000` 至 `0x36000000` 之间。此键盘缓冲区的地址在待机或者休眠之后不会改变。通过这种方式，我们克服了低效扫描全部系统内存以查找随机放置的签名这一困难。在攻击 Linux 内核时，将虚拟地址映射到物理地址并不是一个大问题。通常，在 32 位版本中，一段内核虚拟地址（或者更准确地说，内核逻辑地址 \[参见 31，第 15 章\]）通过减去一个固定的偏移量而被映射到它的物理地址。在 64 位 Linux 版本中，无需使用这样的偏移量。因此无需获知 `CR3` 处理器寄存器的状态。

针对基于 Windows 的目标平台的搜索策略与此不同。为了能够利用搜索路径执行下文所述的搜索，虚拟地址必须被映射到物理地址。这种映射是通过由 Windows 内核创建的页表而实现的。这些页表的内存地址被加载至 `CR3` 寄存器，这是攻击者利用 DMA 所不能访问的。在利用某个简单的驱动程序进行了一些经验测试之后，此用于 _系统进程_ 的页表的物理地址被证明为采用以下两个值之一：`0x122000` 或者 `0x185000`，对于 Windows Vista/7 系统。此系统进程是在 Windows 启动过程中所创建的首个进程。有了这一知识，DAGGER 便可以访问由内核创建的页表并且克服将虚拟地址映射到物理地址这一困难。DAGGER 实现了一种考虑到 PAE 的页表遍历算法。

我们的 Windows 恶意软件查找一个名为 `DeviceExtension` 的结构，它由 USB 键盘驱动程序 `kbdhid.sys` 所维护。此结构包含一块存储着近期按键的击键码的缓存。`kbdhid.sys` 的源代码不可公开获得。获得关于此驱动程序的内部信息的最便捷方式是使用 _IDA Pro_ \[脚注 11\]、_Windows Debugger_（WinDbg）工具，以及由微软以 `pdb` 文件形式提供的调试符号 \[脚注 12\]。为了最终确定该缓冲区在 `DeviceExtension` 结构中的位置，我们的研究始于启动过程的早期 \[参见 105，第 13 章\]。我们了其他的 Windows 内部结构。为了查找用于搜索的起始指针，我们分析了 _内核处理器控制区域_（KPCR \[105，p.62ff\]），或者更加准确地说，`KiInitialPCR`，即用于处理器 0 的 KPCR。我们同样检查了 _对象管理器名称空间目录_（OMND，Windows 对象管理器的一部分）。我们确定了 `KiInitialPCR` 很适合于推导出一条指向 `DeviceExtension` 结构的路径，如图 4.4 所示。`KiInitialPCR` 并非定位于固定的内存地址。DAGGER 不得不在其能够开始如图 4.4 所示的搜索之前应用一个额外步骤。

> 脚注 11：参见 [http://www.hex-rays.com/products/ida/index.shtml](http://www.hex-rays.com/products/ida/index.shtml) \[访问于 2014 年二月 25 日\]

> 脚注 12：参见 [http://msdn.microsoft.com/en-us/windows/hardware/gg462988](http://msdn.microsoft.com/en-us/windows/hardware/gg462988) \[访问于 2014 年二月 25 日\]

> 图 4.4 查找 `DeviceExtension` 结构（简化）

> 有了 `KiInitialPCR` 作为起始点，DAGGER 找到了 OMND，它通过散列值表提供了一条指向驱动程序对象 `kbdhid` 的路径。此对象包含指向设备对象的指针。此设备对象提供了 `DeviceExtension` 结构，它包含击键码缓冲区。

`KiInitialPCR` 的内存位置由 `winload.exe` 二进制文件中的一个名为 `OslpLoadAllModules` 的函数决定，如图 4.5 所示。此二进制文件由 Windows 启动管理器 `bootmgr` 所加载，而后者又由 _主引导记录_（MBR）代码所加载。此函数以某种或多或少地随机化的方式加载 _硬件抽象层_（HAL）库 `hal.dll` 以及 Windows 内核镜像。此内核镜像在一个固定的相对地址包含 `KiInitialPCR`。`OslpLoadAllModules` 的反汇编代码类似于某种 _地址空间布局随机化_（ASLR \[105，p.757\]）机制。

> 图 4.5 查找 `KiInitialPCR`（简化）

> `OslpLoadAllModules` 决定了 Windows 内核镜像和 HAL 的准确位置。

用于内核镜像和 HAL 的内存缓冲区由 `OslpLoadAllModules` 通过一个名为 `BlImgAllocateImageBuffer` 的函数分配。该函数返回对于某一 Windows 系统固定的地址值。这些值可能会因系统不同而不同。对于函数 `BlImgAllocateImageBuffer` 的可能的返回值，共有 64 种不同的 4 kiB 对齐的虚拟地址的理论可能值。这些地址需要被检查以发现内核镜像基地址。对 `BlImgAllocateImageBuffer` 的反汇编揭示了用于地址随机化的种子拥有 5 位的值。这提示了对于（两种）可能的加载顺序情况中的每一种各有 32 种可能的地址，这两种可能的情况是指到底是先加载内核镜像，然后加载 `hal.dll` 还是反过来。只要 `KiInitialPCR` 在内核镜像内部具有固定的虚拟地址，同样多的待检查的虚拟地址数量同样适用于直接搜索 `KiInitialPCR`，而无需处理内核镜像。为了保证 DAGGER 找到的是正确的 `KiInitialPCR`，我们实施了一种 `KiInitialPCR` 签名检查。如果 DAGGER 识别到了正确的 `KiInitialPCR`，它就会继续利用图 4.4 所示的搜索路径查找键盘缓冲区。

我们利用以太网控制器来潜出所捕获的击键码。更准确地说，我们利用 Intel ME 环境的 OOB 特性。然而，没有文档解释如何使用这一特性。因此，我们不得不分析固件以判明如何利用 OOB 信道来潜出击键码。我们能够找到用于在 ME 运行时内存中发送网络数据包的传送环缓冲区。更进一步地，我们还能够从该传送环缓冲区中找到负责发送下一个网络数据包的固件代码。为了潜出所捕获的数据，我们准备了网络数据包，例如如图 4.6 所示的 DHCP 发现数据包。它包含记录下来的击键码。然后，我们将准备好的网络数据包复制到传送缓冲区。随后，我们通过网卡触发，将此数据包发送至某个外部平台。请注意，如果利用外部平台分析网络流量，则很容易发现被传送的数据包。为了增强此设计的隐秘性，我们 \[124，125\] 实现了一种隐秘计时信道，它基于所谓的 Jitterbug \[参见 115\]。

> 图 4.6 包含来自键盘缓冲区的字节的网络数据包

> 此 wireshark 实例执行于某个外部平台上。此网络数据包已经被 wireshark 分析为包含 4 个字节，它代表了所记录的击键码数据。

## 4.4 评估

我们使用一台具有 Q35 芯片组、2 GiB 内存、一块四核 3 GHz CPU，以及 iAMT 固件（版本 3.2.1）的 x86 平台来评估 DAGGER，利用 4 种不同的 32 位操作系统内核：Windows Vista 商用版（服务包 2）、Windows 7 专业版（服务包 1），以及 Ubuntu Linux 内核版本 2.6.32 和 3.0.0。

### 4.4.1 DMA 恶意软件功能的实现

我们根据 4.1 节所述的 DMA 恶意软件定义设计并且实现了我们的 DAGGER 原型。(C1) 显然满足，由于 DAGGER 实现了可运作的击键码记录器功能。DAGGER 在渗透过程中不需要物理访问 (C2)。我们在运行时利用基于软件的漏洞渗透 ME 环境。DAGGER 利用了专用硬件以实现 rootkit 属性 (C3)。我们运行了宿主性能开销测试（内存：MEM，网络：NET，以及 CPU），由于宿主和 ME 环境共享网卡以及内存芯片。并行的网卡和内存访问必须被仲裁，并且可能因此造成延迟。我们的测试结果如图 4.7 所示，并未显示出显著的开销。我们所能检测到的最高开销在搜索阶段扫描宿主内存时大约为 1.5%。这种最小化的性能开销不太可能使得 DAGGER 暴露。

> 图 4.7 宿主性能 CPU、内存和网络开销测试

> 我们使用时间戳计数器以测定开销时间。我们测试了通过网络（NET）以及在内存（MEM）中复制一个 100 MB 的测试文件所需的时间，以及并行计算此测试文件的 SHA1 散列值 10 次所需的时间，这是为了对全部 4 个 CPU 核心（CPU）造成压力。每组基准测试执行了 3 次：没有击键码记录器（基线）、击键码记录器处于搜索模式，以及击键码记录器处于监控模式。对于监控模式，我们将击键码记录器配置为大约每分钟持续发送大约 1000 个网络数据包。这相当于 500 次击键和 500 次释放按键事件。我们重复了每项测试 1000 次。图中的横线表示 1000 次运行的平均值。

如图 4.8 所总结的搜索时间非常短，并且我们所进行的极具侵略性的内存压力测试并不代表通常的计算机系统的内存使用。DAGGER 拥有完全只读的操作以保证其隐秘性。流行的网络嗅探工具 _Wireshark_ \[脚注 13\] 在 Linux 和 Windows 系统上不能检测到任何 DAGGER 流量。宿主防火墙也不能阻止这些流量。即使反病毒软件知道 DAGGER 的签名，它也不能访问 DAGGER 的内存以成功应用签名扫描。此外，我们还运行了一种名为 _Mamutu_ \[脚注 14\] 的软件，除了其他功能以外，它专注于检测击键码记录器行为。即使是专门的软件也不能发现 DAGGER 的任何痕迹。关于判据 C4，我们成功地检查了 DAGGER 的攻击代码能否在平台重启、待机以及关机之后仍然完全可运作。我们确定这取决于一个 iAMT 的 BIOS 选项。我们的代码不能在冷启动之后存活，如果此选项未被设置。

> 脚注 13：参见 [http://www.wireshark.org/](http://www.wireshark.org/) \[访问于 2014 年二月 25 日\]

> 脚注 14：参见 [http://www.emsisoft.com/en/software/mamutu/](http://www.emsisoft.com/en/software/mamutu/) \[访问于 2014 年二月 25 日\]

> 图 4.8 搜索时间测试结果 (a) 和 (b)

> 在 Linux 下利用若干种键盘的测试结果显示了搜索时间约为 1000 ms 的最佳案例和将近 30000 ms 的最差案例，如 (a) 所示。对于所有键盘的平均值为 3281 ms。有利于比较的信息是：对于 Linux（参见 4.3.2 节），扫描全部内存区域用时被测定为 13000 ms。而 30000 ms 的最差案例是由于我们所未能直接处理的错误 DMA 传输。这导致 DAGGER 重复进行搜索阶段。在 Windows 7 上，最佳搜索时间约为 50 ms 而最差搜索时间约为 120 ms，参见 (b)。对于所有键盘的平均值为 93 ms。因此，我们为 Windows 平台所实现的搜索策略的性能远远好于 Linux 的基于签名扫描的策略。

### 4.4.2 有效性和高效性

DAGGER 是高效的，由于它可以永久性地从键盘缓冲区捕获短寿命数据。为了表明 DAGGER 同样是有效的，我们利用不同的 Windows 和 Linux 版本以及若干种键盘测试了 DAGGER。测试得出的搜索时间总结于图 4.8，这确认了 DAGGER 非常高效。我们为每种内核和每种键盘重复测试 100 次。我们的测试发生于平台启动或者重启之后以改变每次运行时的目标地址。Linux 测试结果提示我们能够进一步限制搜索空间。我们能够在我们的测试中最常遇到的最低地址附近开始搜索。大约 2500 ms 的搜索时间是由于目标地址靠近 `0x33c00000`。因此我们能够跳过大约 2500 ms，如果我们在 `0x33c00000` 处开始搜索。更进一步地，我们能够跳过介于 `0x34000000` 和 `0x36000000` 之间的地址范围，由于我们几乎没有在此区域发现目标。大量目标被发现于 `0x36e00000` 附近，即还可以节省大约 12500 ms 的搜索时间。这会增加错失键盘缓冲区地址的几率。这意味着我们可以以牺牲有效性为代价来获取更好的搜索时间。在最佳案例下，搜索时间快到足以捕获诸如硬盘加密口令等。我们利用某个 Linux 系统成功地测试了这一点。Windows 内核可以将内存页交换到硬盘上——而 Linux 则不会。交换的内存页不能被 DMA 恶意软件所发现。因此我们同样对 Windows 进行了一项测试以检查内存交换对 DAGGER 是否有任何影响，如图 4.9 (d) 所示。

> 图 4.9 搜索时间测试结果 (c) 和 (d)

> \(c\) 中的图像比较了不同的目标内核。DAGGER 在 Windows 7 上的性能略好于 Windows Vista。Linux 2.6.32 相对于 Linux 3.0.0 将目标内存结构放置得更加靠近 `0x33000000`，因此 DAGGER 在攻击 Linux 2.6.32 时拥有更多的位于 1000 ms 左右的命中率。(d) 中的结果确认了内存交换对于 DAGGER 的高效性和有效性没有影响。平台重启仅被应用于改变交换行为。尖峰是由于搜索阶段的重启。

### 4.4.3 ME 固件条件

为了能够真正成为隐秘的，DAGGER 确保了 ME 固件一直运行并且正确运行。iAMT 提供了一种网络服务器以用于远程平台管理 \[参见 79，p.215\]，它仍然可用。此服务器在本地平台的 Linux 和 Windows 上正确响应。利用 MEI（参见 4.3.2 节）工作的固件工具在 DAGGER 活动时仍然能够正常工作。我们在 Windows 下成功地测试了 _AMT 状态工具_（作为 _本地管理服务驱动程序_ 的一部分）和 _管理连接工具_（作为 _管理开发者工具包 7.0_ 的一部分）。在 Linux 下，我们成功地测试了 _Intel AMT 开源工具和驱动程序_（版本 5.0.0.30），或者更加准确地说，_ME Status_ 和 _ZTCLocalAgent_ 工具。注意，我们确定 DAGGER 仍然能够运行，即使已经在 BIOS 中禁用了 iAMT 固件。看起来 ME 环境不可能通过任何 BIOS 选项完全禁用。

### 4.4.4 I/OMMU

为了测试 I/OMMU（参见 2.6 节）能否作为对抗 DAGGER 的反制措施，我们在 BIOS 中启用了 Intel VT-d。就我们所知，Windows 并不能直接支持 I/OMMU。我们仍然能够成功攻击 Windows Vista 和 Windows 7，即使 I/OMMU 被激活。Linux 通过额外的努力支持了 I/OMMU 配置。我们同样在 BIOS 中启用 VT-d 并且通过内核命令行激活了 I/OMMU 支持。有了这些额外的步骤，我们能够阻止 Linux 版本的 DAGGER 从操作系统内存中读取短寿命的击键码。这种保护在默认状态下并未开启。在下一节中，除了其他内容以外，我们将会讨论与 I/OMMU 有关的其他问题。

## 4.5 关于反制措施的考虑

利用执行于宿主 CPU 之上的软件来扫描 DMA 恶意软件非常困难。例如，当前的反病毒软件并不会扫描外设的运行时内存，或者宿主 CPU 不能访问此运行时内存，由于某些隔离机制。对于扫描方法的最坏案例是 DMA 恶意软件改变了扫描软件的行为，使其得出错误的结果。如 TCG \[136\] 所提议的加载时固件镜像检查并不能防止运行时攻击。更进一步地，所有 ROM 组件是否都可被宿主访问这一点并不清楚。

### 4.5.1 I/OMMU 相关问题

对于 DMA 攻击的情况，I/OMMU（参见 2.6 节）的恰当配置被诸如 Duflot 等人 \[47\] 所提议为一种预防性的反制措施。这要求由系统软件配置 I/OMMU。不正确的配置不能被排除 \[83，p.2\]。

假设 I/OMMU 是安全的。然而，情况并非总是如此。Sang 等人 \[111\] 展示了 I/OMMU 配置可以被传统 PCI 设备所欺骗。Wojtczuk 等人 \[148\] 揭示了 I/OMMU 可以通过修改由 BIOS 提供的 DMA 重映射引擎数量而被攻击（参见 2.6 节）。这是在 I/OMMU 被系统软件配置之前完成的。我们用于 DAGGER 的环境能够执行此类攻击。此威胁只能通过执行名为 `SINIT` 的依赖于硬件的特定代码来化解。然而，之前至少发生过一次这样的情形，即芯片组厂商未能在芯片组发布时释出 `SINIT` 代码 \[147，p.22\]。此代码对于初始化一个用于诸如虚拟机监视器等的众所周知的、可信的环境来说是必要的。它检查 DMA 重映射引擎，并且由此能够阻止由 Wojtczuk 等人 \[148\] 所呈现的攻击。

`SINIT` 属于可信计算基并且增加了它的大小。前期工作展示了 `SINIT` 代码可能包含可被利用的安全漏洞，这些漏洞可以被用于欺骗 I/OMMU 机制 \[参见 148\]。最近，Wojtczuk 和 Rutkowska \[146\] 呈现了另一种可以被用于绕过 I/OMMU 机制的攻击。为了防止由 Wojtczuk 和 Rutkowska \[146\] 所呈现的攻击，`SINIT` 以及 BIOS 更新必须被应用。Wojtczuk 等人 \[147\] 呈现了另一种 I/OMMU 攻击。注意，`SINIT` 一般在基于虚拟机监视器的平台上被触发。基于通常的操作系统的平台不一定能够依靠 I/OMMU。同样值得提到的是，`SINIT` 要求激活额外的平台特性，即 _可信执行技术_ 和 TPM \[54\]。这意味着诸如那些不想激活 TPM 的用户将不能依靠 I/OMMU。注意，TPM 是一种可选设备 \[参见 54，p.212\]，并且默认被关闭。

为了得到针对 DMA 恶意软件的完全保护，正确配置 I/OMMU 是绝对必要的。然而，I/OMMU 仅在其上方的用于保护整个平台的机制是安全的的情况下才能被看作是安全的。这是一项困难的任务。因此，其他方法由 Li 等人 \[83\] 和 Duflot 等人 \[46\] 所考虑。Li 等人 \[83\] 宣称他们的方法要求对固件进行扩展、并不能在外设造成大量 PCIe 流量的情况下正确地工作，以及验证组件需要知道精确的硬件配置。由 Duflot 等人 \[46\] 所呈现的方法高度针对网卡，并且不适用于诸如 Intel ME 等隔离执行环境。值得注意的是，诸如我们所实现的恶意软件能够在不进行任何网卡固件修改的情况下控制网卡，即数据潜出不能被由 Duflot 等人 \[46\] 所描述的方法检测到。更进一步地，此方法对于宿主 CPU 具有显著的性能问题（某个 CPU 核心 100% 使用）。

由 I/OMMU 强制实施的内存访问策略可能是不充分的，或者甚至可能在某些应用场景中阻止某些其他特性的使用。考虑诸如 _CoPilot_ \[100\] 和 _DeepWatch_ \[25\] 等由硬件支持的恶意软件扫描工具。I/OMMU 可以被配置为阻止 CoPilot 或者 DeepWatch 正常工作，或者允许这些系统访问宿主内存以扫描恶意软件。在后一种情况下，DMA 恶意软件可以利用 CoPilot 或者 DeepWatch 的执行环境来攻击宿主。例如，DAGGER 利用了 DeepWatch 的环境，即 Intel ME。自从 iAMT 版本 5 开始，Intel 支持对于将要执行于 Intel ME 之上的固件进行验证启动 \[参见 79，p.271\]。固件将会在加载时被检查。此加载时检查的结果被提供给系统软件。据我们所知，此结果并未在实践中被使用。此机制不能阻止由我们的概念验证所应用的运行时攻击。这意味着 DAGGER 证实了我们的这一假设，即诸如通过零日漏洞（参见 2.7 节）已经渗透目标系统的攻击者仍然能够雷打不动，即使诸如此类的额外安全机制已经就位。I/OMMU 的恰当配置是对抗 DMA 恶意软件的第一步。但是，如果不能解决上述问题，成功的部署并不能被保证。

### 4.5.2 基于 DMA 副作用的检测方式

一种可能的检测方式基于 DMA 副作用，这种副作用是我们在对自己的 DMA 恶意软件原型 DAGGER 进行首次实验的时候就观察到了的。我们的检测机制基于多种被广泛使用并且跨平台可用的 CPU 特性。

就目前为止，我们开发、实现并且评估了我们的机制，它能够检测到那些并非由宿主系统引发的非预期的恶意 DMA 使用。如果某个外设必须以宿主 CPU 的名义处理数据，则其 DMA 使用由宿主 CPU 引发。利用网卡发送一个网络数据包就是这样的一个范例。预期的 DMA 使用源自外设，并且其本意是用于运行于宿主 CPU 上的软件。接收一个网络数据包就是关于预期 DMA 使用的一个范例。我们的方法能够检测一种普遍的副作用特征。因此我们相信它除了我们自己所实现的 DMA 恶意软件原型以外，还适合于检测其他类型的 DMA 恶意软件。我们对于检测恶意 DMA 使用的调查基于这一知识，即主 CPU 和平台外设都能够在同一时刻请求对主系统内存的访问。内存控制器集线器对并行内存访问请求进行仲裁，参见图 2.5。对于我们来说的有趣问题是，这种并行内存访问是否引入了任何可以测量的副作用。如果此副作用存在并且可测量，则我们可以利用这些副作用来检测恶意行为。

我们启动了一种 Linux 内核并且只启动了一个 root shell 以保持系统负载最小化。只有一个 CPU 核心在线。我们执行了 3 次内存压力测试：没有击键码记录器（基线）、击键码记录器处于搜索模式，以及击键码记录器处于监控模式，同时参见 4.3.3 节。我们使用了一个 100 MB 的文件用于测试，通过将其从某个基于内存的文件系统中的一个位置复制到另一个位置。我们重复了此测试 1000 次并且计算了平均值。结果如图 4.10 所示。此图表揭示了我们如何利用不同的更加专门化的测量工具来精炼我们的策略。

> 图 4.10 内存压力测试

> 搜索阶段和监控阶段被表示为相对于基线的值。

#### GNU Time 测量结果

首先，我们尝试通常的系统工具 GNU time 以测定延时。GNU time 测量的是某个进程的系统资源使用，在我们的案例中即为内存压力测试工具。如图 4.10 左侧显示，所运行的测试结果的平均值几乎相同。我们得出结论，即 GNU time 的测量分辨率不足以揭示我们的实验中的延迟。

#### 时间戳计数器（TSC）测量结果

我们利用一种更加精确的，基于硬件的测量工具，即 TSC \[参见 69，第 17.12 节\] 重复了我们的测量。TSC 对时钟周期进行计数，参见 2.3 节。其结果呈现于图 4.10 中间。我们能够得到或者重现 2% 的开销，如果我们的原型恶意软件处于搜索模式。DMA 最初被引入是为了消除 CPU 负载。这意味着执行内存传输而无需涉及宿主 CPU。_因此，这种开销是一种惊喜，也是关于可检测的 DMA 副作用确实存在的第一组证据_。当我们的原型恶意软件处于监控模式，我们在使用 TSC 时并不能观测到显著的开销。两种模式之间的关键区别在于，在搜索模式中，恶意软件需要复制至少一个内存页以便在其中搜索有价值数据。而在监控模式中，此恶意软件只需从键盘缓冲区复制 4 字节。

#### 硬件性能计数器（HPC）测量结果

我们利用第三种方式重复了测量，即利用 HPC，用于代码优化的一种基于硬件性能监视工具，参见 2.3 节。这些计数器是位于 Intel 处理器上的特殊目的处理器寄存器 \[69，第 18/19 章\]。它们对特定事件进行计数，诸如缓存未命中、分支预测错误，以及资源停止等。类似的 HPC 在诸如 ARM 和 SPARC 等平台上同样可用。我们用于我们的实验的 Intel 平台支持 340 种事件 \[脚注 15\]。我们评估了它们的全部，并且确定资源停止是一种特别有效的 DMA 副作用。对于某些特定事件，HPC 事件计数相对于 TSC 测量更加精确。我们假设资源停止的次数是我们所能利用 TSC 测量得到的延迟的直接结果。作为一个范例，我们在图 4.10 中呈现了一种名为 `RAT_STALLS:ROB_READ_PORT`（参见 2.3 节）的硬件性能计数器所得到的结果。相对于基线，其开销高达 2 倍以上。如果没有我们的原型恶意软件，我们的测量结果是 1359898 次计数事件。如果我们的原型恶意软件处于搜索模式，平均值为 3161868 次计数事件，而在监控模式中时则为 1535054 次计数事件。后者只是略高于基线。这组精炼的测量结果展示了我们的测量越精确，则 DMA 副作用的可见性就越好。

> 脚注 15：我们使用了性能 API 以便在上述实验中配合 HPC 工作，它可以从此处获得：[http://icl.cs.utk.edu/papi/software/index.html](http://icl.cs.utk.edu/papi/software/index.html) \[访问于 2014 年二月 25 日\]

#### 检测

基于我们的发现，DMA 副作用可以被测量。这意味着我们能够设计一种 DMA 恶意软件检测机制。此机制通过建立一组测量基线并且将 TSC/HPC 的测量值与之进行比对而达到目的。在运行时，我们的系统监控 TSC/HPC 测量值并且将其与参比值进行比对。如果这些值偏离参比值，则 DMA 恶意软件就被检测出来了。我们承认关于此种基于延迟的检测方法的某种实际实现仍需进一步调查。在第 5 章，我们呈现了一种改良的检测器，它同样基于 HPC。更进一步地，对于我们的改良的方法，对于检测 DMA 恶意软件而言，人为施加的内存压力不再是必需的。在本节，我们仅仅作为反制措施来讨论 I/OMMU 和一种基于 DMA 副作用的检测方法。

## 4.6 本章小结

在本章中，我们研究了 DMA 恶意软件，即隐藏于专用硬件中的恶意软件。诸如此类的恶意软件可以通过直接访问宿主内存来绕过运行于宿主 CPU 之上的保护机制。我们实现并且评估了 DAGGER，一种基于 DMA 的击键码记录器。专用硬件使得我们的原型能够得益于 rootkit 属性。DAGGER 能够隐秘地运作。它不可由诸如反病毒软件等检测到。我们能够得出结论，与其他已知的 DMA 恶意软件相比，DAGGER 是一种具有代表性的恶意软件概念验证。因此，我们将会在后续章节重复使用 DAGGER 以开发一种可靠的 DMA 恶意软件检测器。

DMA 恶意软件不仅仅是控制一个 DMA 引擎。我们的评估确认了 DMA 恶意软件是高效的，即使诸如内存地址随机化等障碍已经就位。我们同样展示了 DMA 恶意软件可以是有效的，即它可以攻击若干种操作系统。这确认了 DMA 恶意软件的隐秘性无需以牺牲高效性和有效性作为代价。宿主并没有可靠的方式以保护其自身。纵观本章，我们强调了 I/OMMU 具有若干问题，并且宿主不一定能够依赖这种预防性措施以对抗 DMA 恶意软件。除了可能的漏洞以及不同的预设条件必须被满足以成功部署 I/OMMU 以外，最为明显的问题是普通的操作系统并不支持 I/OMMU，或者支持不充分。因此 DMA 恶意软件可以攻击诸如 Windows 等操作系统。用于扫描专用设备以查找恶意软件的通用并且可靠的方法并不存在。需要一种可靠并且更加通用的 DMA 恶意软件检测机制。其他研究者也调查了 I/OMMU 的替代品。

在本章中，我们讨论了一种替代方法。我们的检测方法基于这样一种现象的观察，即来自隔离硬件（通过 DMA）和来自宿主 CPU 的并行内存访问造成了可测量的副作用。因此我们可以得出结论，即非法 DMA 操作不再是隐秘的。此外，我们不得不承认用于此检测方法的实验设置包含大量人为因素。我们得出结论，当前的设置不足以作为可以在实践中应用的检测工具。然而，我们展示了硬件性能计数器可以作为可靠的检测工具的基础。我们揭示了测量工具必须具有足够的测量分辨率。硬件性能计数器满足这一要求。我们将会在下一章更加详细地调查这一点。

没有替代品，只有那些其内部工作方式对于宿主可以访问，即完整的内存和只读存储器访问的专用硬件应该被部署。这使得宿主能够时时刻刻地检查该设备以查找恶意代码。关于这一点的一个前提条件是一种合理的测定策略，以及扫描程序得以首先加载。具有专用处理器、专用运行时内存以及 DMA 引擎的设备对于宿主平台来说是一种威胁。本章展示了需要额外的保护机制以确保平台的机密性和完整性，以及特别是它们的可信性。

