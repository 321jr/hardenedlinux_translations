# 第 5 章 DMA 恶意软件检测初步

> 您不能防御，您不能预防。您所能做的只有检测并且作出回应。——Bruce Schneier，美国密码学家，计算机安全和隐私专家

上一章呈现了计算机平台外设可以被利用以攻击宿主计算机平台。更准确地说，是那些诸如网卡、显卡以及管理控制器等专用硬件。专用硬件为攻击者提供了隔离的执行环境，该环境不会被代表了业界最先进技术的反病毒软件、入侵检测系统以及其他在市场上可获得的系统软件安全特性所考虑。因此，专用硬件非常适合于隐秘攻击 \[35，36，46，123，134，135\]。诸如此类的攻击也已经被整合进漏洞利用框架中 \[19，18\]。

例如，Duflot 等人 \[47\] 呈现了一种基于网卡（NIC）的攻击以便运行远程 shell 并且接管该宿主。他们使用利用了某个安全漏洞的攻击代码来渗透网卡。Triulzi \[134，135\] 展示了如何利用网卡和显卡（VC）的组合来访问主内存以允许攻击者偷取密码学密钥及其他敏感数据。Triulzi 远程利用了固件更新机制的漏洞以使得攻击代码进入该系统。

在第 4 章，我们描述了我们是如何利用某个集成在计算机平台上的内存控制器集线器（MCH）中的微控制器的漏洞来隐藏一个击键码记录器的，它被用于捕获诸如口令等机密数据。所有这些攻击的共同点是它们都拥有通过直接内存访问机制对主内存的访问。通过如此做，这些攻击绕过了由宿主系统软件设置的加固安全机制。更进一步地，这些攻击并不需要利用任何宿主系统软件漏洞。具有执行 DMA 传输的能力的设备称为总线主控，参见 2.5 节。在其他总线主控访问主内存时，通常运行着安全软件以揭示攻击的宿主 CPU 并不一定被涉及进来，参见第 4 章。由于诸如外设元件高速互连标准（PCIe）等现代总线架构的出现，一种必须由宿主 CPU 来配置的唯一中央 DMA 控制器已经过时。执行于专用硬件的隔离执行环境中的固件能够配置该外设的 DMA 引擎以读取或者写入主内存的任意位置，这对于宿主 CPU 来说 _不可见_。

在本章中，我们呈现了我们的 _总线代理运行时监视器_（BARM）——它是一种能够揭示并且终止针对平台主内存的基于外设的隐秘攻击的监视器。我们开发 BARM 是为了证实这一点，即宿主 CPU 能够检测到源自平台外设的针对平台主内存的额外（恶意）访问，即使宿主 CPU 不能访问可疑外设的隔离执行环境。关于额外访问，我们是指其本意并非代表宿主系统软件而进行的数据传送或者传输等访问。BARM 基于这样一种原型，它能够分析内存总线活动。它将由诸如操作系统或者虚拟机监视器等宿主系统软件所预期的总线活动同实际总线活动相比较。如果 BARM 检测到的总线活动多于宿主系统软件所预期的，则它将会报告基于 DMA 的攻击。BARM 还能识别恶意外设。

在前几章，我们还呈现了人们所提议的若干种考虑了 DMA 攻击的预防方法。例如，Intel 开发了一种输入/输出内存管理单元（I/OMMU），并且将此技术称为用于直接 I/O 的 Intel 虚拟化技术（VT-d \[2\]）。I/OMMU 可以被应用以限制对于主内存的访问。VT-d 的目的在于为流行的 x86 平台提供硬件虚拟化支持。然而，由于若干种原因，I/OMMU 不一定能够被信任为一种针对 DMA 攻击的反制措施。例如，I/OMMU (i) 必须被无瑕疵地配置 \[83\]，(ii) 可以被成功地攻击 \[111，148，147，146\]，以及 (iii) 当存在内存访问策略冲突时不能被应用，参见第 4 章。更进一步地，I/OMMU 并不能被每一种芯片组或者系统软件（例如 Windows Vista 和 Windows 7）所支持。另一种预防方法是在加载时检测外设固件的完整性。然而，这样的加载时检查并不能防止运行时攻击。无限重复进行此类检查以防止运行时攻击的代价是系统性能的损失。注意，这同样并不一定能够捕获瞬时攻击。更进一步地，宿主 CPU 是否能够访问用于存储平台固件的全部只读存储器这一点并不清楚。

在本章中，我们应对了这一挑战，即利用一种运行于宿主 CPU 之上的原型来检测恶意 DMA。通过监控总线活动，我们的方法并不要求能够访问该外设的 ROM 或者其执行环境。我们的原型被作为平台的系统软件的一部分而实现。其基本理念是：攻击者在访问平台的主内存时不能避免造成额外的总线活动。这些额外的总线活动是基于 DMA 的攻击的死穴，而我们正是利用这一弱点来揭示并且终止该攻击。我们的概念验证 BARM 实现了一种考虑了瞬时攻击的监控策略。我们的技术的主要目标是监视连接到内存总线的设备对内存的访问。特别地，宿主 CPU 核心为大量进程存取数据和指令。而诸如网卡和硬盘等外设带来的输入和输出（I/O）更加剧了这种情形。BARM 展示了如何应对这些挑战。

在本章中，我们呈现了一种方法以检测并且化解基于 DMA 的攻击。我们的主要贡献包括：

* **用于揭示攻击的预期总线活动模型以及真实总线活动的测量方法**：本章呈现了一种新的机制以通过某个执行于宿主 CPU 之上的原型来监控完整的内存总线活动。我们的方法基于对预期的内存总线活动进行建模。更进一步地，我们呈现了一种技术以用于监视实际的总线活动。我们通过模型预期的活动与实际测量得到的活动之间的差值来揭示恶意内存访问。任何额外的 DMA 活动可以被预设为攻击行为。
* **解除恶意外设的能力**：我们能够检测到发动攻击的外设。我们在一种我们称其为 BARM 的概念验证中实现并且评估了我们的检测模型。BARM 是足够高效和有效的，以使得它不仅仅能够检测到，并且还能够在攻击者能够造成任何伤害之前消除基于 DMA 的攻击的威胁。
* **运行时监视测量策略**：我们实现了一种用于永久运行时监控的测量策略，它以可忽略的性能开销考虑了瞬时攻击，得益于 x86 平台上可用的 CPU 特性。

最后，我们的解决方案并不要求修改硬件或者固件。

## 5.1 通用检测模型

我们的检测模型的基础包括两个核心点。其一，内存总线是一种共享资源（参见图 5.1）。其二，系统软件，即操作系统，以 I/O 统计的形式记录了所有 I/O 活动。总线主控（CPU 和外设）通过内存总线连接到主内存。此总线为主内存提供且仅提供了一个必须被所有总线主控所共享的接口，参见图 5.1。我们将此共享资源看作某种 _挂钩_，或者称其为攻击者的死穴。此共享资源的事实可以被宿主 CPU 所利用以确定是否有其他总线主控正在使用该总线。例如，如果宿主 CPU 在一定时间内不能访问该总线，则操作系统可以得出结论，即其他总线主控正在使用该总线。

> 图 5.1 总线主控拓扑结构被利用以揭示恶意内存访问

> 如果测量得到的总线活动值 _A_<sub>m</sub> 和预期的总线活动值 _A_<sub>e</sub> 之差大于 0，则额外的总线活动 _A_<sub>a</sub> 被检测出来，并且 DMA 攻击被揭示出来。

宿主 CPU / 操作系统能够多么精确地确定恶意总线活动取决于实现。我们调查了多种基于计时测量和总线传输监视地指导意见。例如，对总线传输的计时测量实验由 Li 等人 \[83\] 描述。内存传输的计时测量方法给出于 4.5.2 节。我们的实验揭示了总线传输事件计数是最为可靠的方法。我们于 5.2 节呈现了这种新方法的实现。

## 5.2 检测模型的一种实现

在本节中，我们描述了我们自己的基于总线传输事件计数的通用检测模型的实现。我们的概念验证的目标是确认宿主 CPU 能够检测到源自外设的基于 DMA 的攻击。我们为 Intel x86 平台实现了 BARM。我们将 BARM 作为一个 Linux 内核模块来开发。根据第 4 章所描述的实验，执行于具有独立 DMA 引擎的外设上的恶意软件可以隐秘地访问主内存。当基于 DMA 的内存传输被建立时，宿主 CPU 不一定被涉及进来。然而，内存总线不可避免地是一种共享资源，它由 MCH 来仲裁，参见图 2.5。这是我们为何期待总线主控在访问主内存时会产生副作用的原因。

我们分析了性能监视单元（PMU，参见 2.3 节）的能力以发现并且利用这样的 DMA 副作用。PMU 被实现为模型特定寄存器。这些寄存器可以被配置为对与性能相关的事件进行计数。PMU 的本意并非用于检测计算机系统上的恶意行为。它们的目的是检测性能瓶颈以允许开发者相应地改良受到影响的软件的性能 \[104\]。在本工作中，我们利用 PMU 以揭示针对平台主内存的基于外设的隐秘攻击。执行于外设的恶意软件不能访问处理器寄存器，因此也就不能通过修改 PMU 处理器寄存器来对宿主 CPU 隐藏其活动。我们的分析揭示了可以被 PMU 计数的内存传输事件。特别地，一种称为 `BUS_TRANS_MEM` 的计数事件总结了所有突发（完整缓存线）、部分读 / 写（非突发），以及无效内存传输 \[71\]。这正是 BARM 的基础。

取决于精确的处理器架构，Intel 处理器为每个处理器核心提供了 5 到 7 个性能计数器寄存器 \[69，第 18 章\]。在此种情况下，利用一个处理器核心最多可以并行计数 5 到 7 个事件。这些寄存器中的 3 个是固定功能寄存器，即它们所计数的事件不可更改。其他计数器是通用目的计数器，我们可以将其用于 BARM 以对特定的 `BUS_TRANS_MEM` 事件进行计数。如果我们正确地应用 `BUS_TRANS_MEM` 计数器，我们就能够成功地测量 _A_<sub>m</sub>。此时，这一知识并不足以确定此传输是否排他性地与某一操作系统任务相关联，或者这其中是否有恶意传输。在下文中，我们为揭示源自某个受到攻击的具有 DMA 能力的外设的恶意传输奠定基础。

### 5.2.1 总线主控分析

在下文中，我们就其所造成的总线传输数量对宿主 CPU（与处理器总线系统相关）以及通用主机控制器接口（UHCI）控制器（与 PCIe 总线系统相关）的总线主控进行了分析。通过如此做，我们考虑了共享内存总线的总线系统中最重要的部分。其他总线主控，诸如硬盘和以太网控制器，可以按照某种类似的方式进行分析。

#### 宿主 CPU

宿主 CPU 可能是最具挑战性的总线主控。CPU 造成巨大数量的内存传输。若干个处理器核心为众多进程存取指令和数据。针对由它们所造成的总线活动来高效地监控所有这些系统进程几乎不可能。因此，我们决定这样来分析宿主 CPU 的总线代理行为，即利用 `BUS_TRANS_MEM` 事件，并且与某些控制选项以及所谓的事件名称扩展相结合。我们实现了一种用于此类分析的 Linux 内核模块。我们的关键结果包括：(i) 由用户空间和内核空间的进程造成的总线事件可以由同一个计数器来计数。(ii) 事件名称扩展 `THIS_AGENT` 和 `ALL_AGENTS` 可以同 `BUS_TRANS_MEM` 事件 \[参见 71\] 配合使用以区分由宿主 CPU 以及所有其他处理器总线系统上的总线主控所造成的总线传输。`THIS_AGENT` 对与属于某个 CPU 总线代理的所有处理器核心相关的所有事件进行计数。而 `ALL_AGENTS` 则对连接到宿主 CPU 所连接到的总线的所有总线代理的事件进行计数。`ALL_AGENTS` 扩展对于我们的实现至关重要。它允许我们以总线传输数量的形式测量总线活动值 _A_<sub>m</sub>（参见 5.1 节）：

_A_<sub>m</sub> = BUS\_TRANS\_MEM.ALL\_AGENTS （公式 5.1）

更进一步地，我们的分析揭示了一块宿主 CPU 并不一定准确地就是一个总线代理。一块多核心处理器可能包含若干个总线代理。例如，我们使用的是一块四核处理器（Intel Core 2 Quad CPU Q9650 @ 3.00 GHz），它包含两个总线代理。两个处理器核心共用一个总线代理，如图 5.2 所示。因此，对于判定合法或者非法传输，处理器核心的数量至关重要。注意，如果宿主 CPU 拥有若干个总线代理，有必要为每个总线代理启用一个计数器，并且带有 `THIS_AGENT` 事件名称扩展。有了这一知识，我们就可以确定所有总线主控的总线主控传输 _A_<sub>m</sub>。我们能够区分宿主 CPU 的总线活动（参见公式 5.2）和由通过 MCH 访问主内存的所有其他总线主控所造成的总线活动（参见公式 5.3）。

_A_<sub>m</sub><sup>CPU</sup> = ∑<sub>_n_=0</sub><sup>_H_</sup> BUS\_TRANS\_MEM.THIS\_AGENT<sub>cpu\_bus\_agent\#_n_</sub>, _H_ ∈ N, _H_ = 宿主 CPU 总线代理数量 - 1 （公式 5.2）

<SPAN style="TEXT-DECORATION: overline">_A_<sub>m</sub><sup>CPU</sup></SPAN> = _A_<sub>m</sub> - _A_<sub>m</sub><sup>CPU</sup> ⇔ _A_<sub>m</sub> = _A_<sub>m</sub><sup>CPU</sup> + <SPAN style="TEXT-DECORATION: overline">_A_<sub>m</sub><sup>CPU</sup></SPAN> （公式 5.3）

> 图 5.2 Intel 四核处理器

> 四核处理器包含两个总线代理，每个总线代理包含两个核心，参见 (a)。当同时利用两个总线代理，即 (b) 中的 `BA#0` 和 `BA#1` 对 `BUS_TRANS_MEM` 事件进行计数时，`THIS_AGENT` 名称扩展带来了显著的区别。(b) 中的内核日志同样描述了对应于名称扩展 `ALL_AGENTS` 的值在同一个计数器查询迭代内基本相同。

这意味着我们可以减去由所有处理器核心上运行着的用户空间和内核空间进程所造成的所有合法传输。注意，根据我们的信任和对手模型（参见 2.7 节），测量得到的宿主 CPU 的总线活动值和预期的宿主 CPU 总线活动值相同（_A_<sub>e</sub><sup>CPU</sup> = _A_<sub>m</sub><sup>CPU</sup>），由于运行于宿主 CPU 上的所有进程都可信。类似地，预期的总线活动值也可被分割，即 _A_<sub>e</sub> = _A_<sub>e</sub><sup>CPU</sup> + <SPAN style="TEXT-DECORATION: overline">_A_<sub>e</sub><sup>CPU</sup></SPAN>。

#### 通用主机控制器接口控制器

_通用主机控制器接口_（UHCI）控制器是一种用于 _通用串行总线_（USB）设备，诸如 USB 键盘或者 USB 鼠标等的 I/O 控制器。USB 设备由 I/O 控制器轮询以检查是否有新数据。系统软件需要为 UHCI 控制器准备一组计划。此计划决定了某一被连接的 USB 设备如何被 I/O 控制器轮询。UHCI 控制器持久性地从主内存中检查其计划。显然，这一过程造成了大量总线活动。如果某次轮询报告有新数据可用，则更多的总线活动将会由 USB 设备产生。在下文中，我们将会分析这将会产生多少活动，即在为某个 USB 设备服务时，多少字节将会通过 UHCI 控制器传输。

在我们的案例中，I/O 控制器每毫秒分析其计划。这意味着控制器将会查找称为传输描述符的数据结构。为了获得描述符，控制器在每毫秒从某个列表中读取一个框架指针。一个框架指针（物理地址）引用到当前时间框架的传输描述符。传输描述符被组织进队列中。一个队列以队首开始，它可能包含一个指向首个传输描述符的指针，以及一个指向下一个队首的指针 \[参见 62，p.6\]。根据 Intel \[62\] 的说法，框架（指针）列表包含 1024 个项目，其大小为 4096 字节。UHCI 控制器需要 1024 ms（每毫秒 1 个项目）用于一个框架（指针）列表的迭代过程。借助于 Linux 的 UHCI 主机控制器设备驱动程序的最高调试模式，我们分析了一次迭代的总线传输数量。在该模式下，计划信息被映射到调试文件系统。我们确定了这些框架指针引用到中断传输队列（参见图 5.3 (d.i) 和 (d.ii)：`int2`，`int4`，……，`int128`），以及一个称为 `async` 的队列。`int2` 的涵义是，此队列被每隔 2 个框架指针引用，`int4` 指每隔 4 个，`int8` 指每隔 8 个，以此类推。`async` 队列被每隔 128 个框架指针引用。

> 图 5.3 UHCI 计划信息（简化）

> 此计划显示了 `int` 和 `async` 队列正在被使用。队列连接目标的物理地址被显示于方括号中。用于终止的队列连接或者队列元素所包含的值为 `00000001` 而非物理地址。此 `int16` 队列为我们的 USB 键盘负责。

未被指认的中断传输队列，即并未被用于轮询某一 USB 设备的队列，被重定向到 `async` 队列的队首，参见图 5.3 (b)。分析 `async` 队列要求 3 次内存读取访问，如图 5.3 (a) 所示。分析已被指认为轮询某一 USB 设备的中断传输队列需要多于 4 次内存读取。精确的内存读取次数取决于该队列中拥有多少元素。通常，如果该队列被指认给 USB 键盘，它只有 1 个元素。该队列可能还会拥有 2 个元素，例如该队列被指认给 USB 键盘和鼠标。如果该队列只有 1 个元素，分析整个被指认的中断传输队列需要 6 次内存读取，参见图 5.3 (c)。

我们的检查结果总结如下：

\#总线读取传输 = 8 \* \#async 读取 + 8 \* \#int128 读取 + 16 \* \#int64 读取 + 32 \* \#int32 读取 + 64 \* \#int16 读取 + 128 \* \#int8 读取 + 256 \* \#int4 读取 + 512 \* \#int2 读取 （公式 5.4）

如果 `int16` 被指认给 USB 键盘，计算得到总共需要 4216 次总线读取，如图 5.3 (d) 所示。根据 Intel \[62\] 的说法，UHCI 控制器需要更新队列元素。我们期待这一点对应于 `int16` 队列的队列元素。此队列被 64 个框架指针所引用。因此，我们计算得到 64 次内存写入访问。这意味着总线传输的总数是 4280。我们成功地利用一块 Dell USB 键盘以及一块 Logitech USB 键盘，配合 UHCI 控制器的单步调试模式 \[参见 62，p.11\] 验证了这种行为，此信息通过位于 `/sys/kernel/debug/usb/uhci/` 的 Linux 调试文件系统以及用于计数 `BUS_TRANS_MEM` 事件的性能监视单元所获取。

利用同样的设置，我们确定了当 USB 设备拥有新数据需要传输至主内存时所需的总线传输数量。对于 USB 键盘，我们精确地确定了需要且只需要 2 次总线传输以处理一次击键事件。这同样适用于按键释放事件。Linux 驱动程序通过中断例程来处理此类事件。因此，为了确定预期的总线活动 _A_<sub>e</sub><sup>UHCI</sup>，我们需要来自操作系统的已处理中断的数量并且复制它。这意味着我们的范例中的总线传输总数是 _A_<sub>e</sub><sup>UHCI</sup> = 4280 + 2 * \#USB 中断。

#### 额外的总线主控

为了处理整个计算机平台上的总线活动，诸如以太网控制器和硬盘控制器等所有其他总线主控的行为必须以类似于 UHCI 控制器的方式进行分析。当我们在一台 Lenovo ThinkPad 笔记本计算机测试我们的检测模型时，我们不得不分析一个额外的总线主控。我们不能在早期 ThinkPad 型号上通过 BIOS 关闭指纹读取器（FR）。因此，我们分析了指纹读取器并且在我们的实现中考虑了这个总线主控。我们确定了它会造成每毫秒 4 次总线传输。对于本工作，或者更准确地说，为了显示宿主 CPU 能够检测 DMA 攻击，对于 BARM 而言，考虑最多 5 个总线主控就足够了。除了基于 CPU 的两个总线主控以及 UHCI 控制器以外，我们还将 Intel 管理引擎（ME）看作一个总线主控。在正常操作中，我们假设 _A_<sub>e</sub><sup>ME</sup> = 0。为了能够显示我们的检测模型适用于某一计算机平台，我们并未在我们的实验中使用该平台上的全部总线主控。例如，我们在我们的评估中的某些测试中从计算机的主内存中运行 Linux 操作系统（参见 5.3 节）。这允许我们按需使用硬盘控制器的 I/O 功能。

有了本节中所呈现的分析，我们已经能够确认哪个总线主控造成了多少内存传输。这些中间结果如图 5.4 所示。

> 图 5.4 对由 3 个活动的总线主控造成的内存传输进行分解

> 最上方的曲线描述了（在我们的设置中的）所有活动的总线主控所造成的所有内存传输数量，即 _A_<sub>m</sub>。其下方的曲线描述了 _A_<sub>m</sub> 减去第一个 CPU 总线主控的预期内存传输，即 _A_<sub>m</sub> - _A_<sub>e</sub><sup>CPU BA\#0</sup>。再下方的曲线代表 _A_<sub>m</sub> - _A_<sub>e</sub><sup>CPU BA\#0</sup> - _A_<sub>e</sub><sup>CPU BA\#1</sup>，最下方的曲线表示 _A_<sub>m</sub> - _A_<sub>e</sub><sup>CPU BA\#0</sup> - _A_<sub>e</sub><sup>CPU BA\#1</sup> - _A_<sub>e</sub><sup>UHCI</sup>。

### 5.2.2 总线代理运行时监视器

有了我们于 5.2.1 节引入的总线主控分析，我们就能够以 Linux 内核模块的形式实现 BARM。在本节中，我们描述了我们是如何实现一种能够永久地监控并且评估总线活动地监控策略的。性能监视单元已经被配置为测量 `BUS_TRANS_MEM` 事件。对于 _A_<sub>m</sub>，即 _A_<sub>m</sub><sup>CPU</sup> 和 <SPAN style="TEXT-DECORATION: overline">_A_<sub>m</sub><sup>CPU</sup></SPAN> 的永久监控采用如下步骤实现：

1. 重置计数器并且存储所有非 CPU 总线主控（例如 UHCI、FR、ME、硬盘控制器（HD）、以太网控制器（ETH）、视频控制器（VC） 等）的初始 I/O 统计数据。
2. 开始对于一定时间 _t_ 的计数（采用高精度计时器实现）。
3. 当到达时间 _t_ 时停止计数。
4. 存储对应于 _A_<sub>m</sub> 和 _A_<sub>m</sub><sup>CPU</sup> 的计数器的值（参见 5.2.1 节），并且更新所有非 CPU 总线代理的 I/O 统计数据
5. 继续步骤 (1)，并且通过唤醒对应的评估内核线程来并行确定 _A_<sub>e</sub>。

我们还需要比较测量得到的总线活动和预期总线活动。BARM 在按照如下步骤执行评估内核线程时比较 <SPAN style="TEXT-DECORATION: overline">_A_<sub>m</sub><sup>CPU</sup></SPAN> 和 <SPAN style="TEXT-DECORATION: overline">_A_<sub>e</sub><sup>CPU</sup></SPAN>：

1. 利用所存储的对应于 _A_<sub>m</sub> 和 _A_<sub>m</sub><sup>CPU</sup> 的计数器的值来确定 <SPAN style="TEXT-DECORATION: overline">_A_<sub>m</sub><sup>CPU</sup></SPAN>（参见 5.2.1 节）。
2. 利用 _A_<sub>e</sub><sup>UHCI</sup>、_A_<sub>e</sub><sup>FR</sup>、_A_<sub>e</sub><sup>ME</sup>、_A_<sub>e</sub><sup>HD</sup>、_A_<sub>e</sub><sup>ETH</sup> 和 _A_<sub>e</sub><sup>VC</sup> 等来计算 <SPAN style="TEXT-DECORATION: overline">_A_<sub>e</sub><sup>CPU</sup></SPAN>，这些值来自于所存储的更新过的 I/O 统计数据与所存储的初始 I/O 统计数据之差值。注意，对于我们的实现，我们假设 _A_<sub>e</sub><sup>HD</sup> = 0，_A_<sub>e</sub><sup>ETH</sup> = 0 等。
3. 比较 <SPAN style="TEXT-DECORATION: overline">_A_<sub>m</sub><sup>CPU</sup></SPAN> 和 <SPAN style="TEXT-DECORATION: overline">_A_<sub>e</sub><sup>CPU</sup></SPAN>，报告结果，并且如有必要则应用某种防御机制。

#### 容错值

出于实践性，我们需要重新定义如何计算 _A_<sub>a</sub>。我们利用 _A_<sub>a</sub> 来解读我们的概念验证实现中的 PMU 测量结果。原因之一是 PMU 计数器不能被同时开始 / 停止。开始 / 停止某个计数器需要非常少的处理器周期，并且计数器是被逐个开始 / 停止的。同样的事情可能发生于非常短的时间之内，在此，计数器被停止以便被读取和重置（参见永久监控时的步骤 (3) 和步骤 (2) 之间的时间框架）。类似的不精确性可能发生于读取操作系统 I/O 统计数据时。因此，我们引入了容错值 _T_ ∈ N，并且精炼 _A_<sub>a</sub>：

_A_<sub>_T_<sub>a</sub></sub> = 0, 如果 \|_A_<sub>m</sub> - _A_<sub>e</sub>\| ∈ \{0, ..., _T_\}</br>_A_<sub>_T_<sub>a</sub></sub> = \|_A_<sub>m</sub> - _A_<sub>e</sub>\|, 如果 \|_A_<sub>m</sub> - _A_<sub>e</sub>\| ∉ \{0, ..., _T_\} （公式 5.5）

_T_ 的值是可以自由选择的数字，用于表示 BARM 在检查额外的总线流量时可以容忍的总线传输次数。我们的评估显示了有用的 _T_ 是一个非常小的值（参见 5.3 节）。此外，我们必须考虑 _T_ > 0 的值在理论上赋予了攻击者隐藏攻击的机会，即发动瞬时攻击的机会。在最佳案例中（参见图 5.5），此隐秘攻击可以最多拥有 2 _T_ 的总线传输。然而这 2 _T_ 的总线传输不太可能足以用于一次成功的攻击。而在平台重启之后，数据很可能不在同一内存位置。因此，内存必须被重新扫描以查找有价值数据，而这需要大量的总线传输。由现代操作系统所应用的地址空间布局随机化（ASLR，同时参见 4.3.3 节）等机制同样使得搜索过程复杂化。这会导致更多的总线传输。更进一步地，攻击者需要知道 BARM 不得不容忍 - _T_ 传输的非常精确的时间点。

> 图 5.5 容错值 _T_

> 如果攻击者能够预测非常精确的时刻，在此 BARM 认为 _T_ 是太少的总线传输，则具有 2 _T_ 的总线传输的攻击在理论上可以隐秘地执行。

#### 识别并且禁用恶意外设

如果 _A_<sub>_T_<sub>a</sub></sub> > 0，则 BARM 检测到了来自某个平台外设的基于 DMA 的攻击。知道有这样的攻击正在被执行已经具有很大价值。可以被应用于阻止一次攻击的一种简单的防御策略是利用所有不可信的总线主控的 BME 位（参见 2.5 节）来移除其总线主控能力。这样一种策略可能并不充分，如果所有平台特性都被要求能够运作。而如果没有进一步措施，这也可能导致数据丢失。然而，一台受到这样一种有目标的攻击的系统应该被下线以接受仔细的检查。

在终止不可信的总线主控时，BARM 会在平台屏幕上为用户放置一则通知。_A_<sub>_T_<sub>a</sub></sub> 并不包含任何关于何种平台外设正在执行攻击的信息。为了在通知消息中包含此信息，我们实现了一种能够识别可疑外设的简单外设测试。在当 DMA 攻击仍在查找有价值数据时，我们通过逐个解除不可信的总线主控的 BME 位来揭示恶意外设。在 BME 位解除之后，BARM 检查额外总线活动是否消失。如果消失，则恶意外设被识别出来，并且该外设的名称被添加到攻击通知消息中来。如果 BARM 仍然检测到额外的总线活动，则此错误外设的 BME 位被重新设置。在外设测试阶段，操作系统必须不能触发任何 I/O 任务。我们的评估结果揭示了我们的测试可以在几毫秒之内执行完毕，参见 5.3 节。攻击行为处于活动的时间需要略长于我们的外设测试，否则，我们的测试便不能保证识别出恶意外设。第 4 章所述的针对 Linux 系统的 DMA 攻击需要 1000 ms 到 30000 ms 以扫描内存。我们的评估显示了 BARM 能够快得多地检测并且终止这一 DMA 攻击。

## 5.3 关于检测模型实现的评估

我们评估了作为 Linux 内核而实现的 BARM。首先，我们引导了一些测试以确定有用的容错值 _T_。在本节的主要部分，我们呈现了关于我们的解决方案的性能开销评估。我们显示了由 BARM 造成的开销是可忽略的。最后，我们引导了一些实验以评估在攻击过程中 BARM 的行为。

### 5.3.1 容错值 _T_

我们执行了若干组不同的测试以确定一个有用的容错值。我们重复了本组测试 100 次。若干种不同的测试意味着我们对于 BARM 评估了不同的 PMU 值采样区间（32 ms，128 ms，512 ms，1024 ms 和 2048 ms）、不同的 CPU 核心数（1 至 4 个核心）、不同的内存大小（2 GiB，4 GiB，6 GiB 和 8 GiB）、不同的平台（Intel Q35 台式机 / Lenovo ThinkPad：T400，X200，X61s），以及最低（节能模式）和最高（性能模式）CPU 频率，以检查它们对 _T_ 的影响。更进一步地，我们对 BARM 进行了 CPU 和内存压力测试评估。CPU 压力测试意味着并行运行针对一个 100 MB 的测试文件的 `sha1sum` 命令 100 次以保证 CPU 使用率 100%。对于内存压力测试，我们将此 100 MB 的测试文件从主内存中的一个位置复制到另一个位置 2000 次。我们的平台拥有如下配置：Q35——Intel Core 2 Quad CPU Q9650 @ 3.00 GHz，4 GiB 内存；T400——Intel Core 2 Duo CPU P9600 @ 2.66 GHz，4 GiB 内存；X200——Intel Core 2 Duo CPU P8700 @ 2.53 GHz，4 GiB 内存，以及 X61s——Intel Core 2 Duo L7500 @ 1.60 GHz，2 GiB 内存。我们将采样区间 32 ms，1 个 CPU 核心，4 GiB 内存，Q35 平台，以及最大 CPU 频率作为基本评估配置。在每次测试中，我们只更改这些属性中的一个。结果总结于图 5.6 中。

> 图 5.6 确定足够的容错值 _T_

> 图 (a)-(f) 呈现了利用不同测试对 BARM 进行评估时的 _A_<sub>a</sub> 计算结果的差值。BARM 执行了每种测试 100 次以确定 _A_<sub>a</sub>。关于差值，我们是指最大和最小 _A_<sub>a</sub> 之差。图 (a)-(f) 以盒图的形式显示了差值。对于每一种测试，对应的 _A_<sub>a</sub> 的最小值、较低的四分位数、中位数、较高的四分位数以及最大值被描述出来。最小值和最大值之间的小点表示 _A_<sub>a</sub> 平均值。_A_<sub>a</sub> 的值一般位于 -10 到 10 之间。最大的绝对值为 19，参见图 (e) 之 X61s。

注意，为了确定 _T_，我们考虑了最多 5 个总线主控（1 至 2 个 CPU，一个 UHCI，一个指纹读取器，以及一个 ME 的总线主控）。我们使用 SliTaz Linux 发行版 \[脚注 16\]，它允许我们从内存运行 Linux 操作系统。其结果是我们能够选择性地激活或者取消激活诸如硬盘控制器总线主控这样的不同组件。总体测试结果展示了一种最差案例，其测量得到的和预期的总线传输之差值为 19（绝对值）。这一结果确认了这种关于总线活动的测量和评估能够得到可靠的值，即这些数值几乎没有任何波动。然而，为了安全起见，我们在利用一种基于 DMA 的隐秘击键码记录器评估 BARM 时使用的容错值是 _T_ = 50，参见 5.3.3 节。

> 脚注 16：参见 [http://www.slitaz.org/](http://www.slitaz.org/) \[访问于 2014 年二月 25 日\]

### 5.3.2 永久监控时的性能开销

由于 BARM 仅仅直接影响宿主 CPU 和主内存，我们评估了关于这两种资源的性能开销。BARM 在监控时并不访问硬盘或者网卡。我们利用 64 位 Ubuntu 内核（版本 3.5.0-26）评估了 BARM。在测试过程中，我们以最高频率运行宿主 CPU 以使其造成尽可能多的总线活动。更进一步地，我们使用 1 个或者 2 个 CPU 总线主控来执行我们的测试，以确定 CPU 总线主控的数量是否对于性能开销具有任何影响。最终，我们需要为第二个 CPU 总线主控使用更多的处理器寄存器（PMU）。另一件重要的事情是对采样区间的评估。因此，我们利用不同区间对 BARM 进行了配置并且检查了开销。为了测量开销，我们为所有测试使用了时间戳计数器（参见 2.3 节）。这些评估的结果如图 5.7 所示。

> 图 5.7 宿主性能 CPU 和内存开销评估

> 我们利用内存（MEM）和 CPU 基准测试测量了开销。每次测试使用 1 个在线的 CPU 核心（1 个 CPU 总线主控）或者 4 个在线的 CPU 核心（2 个 CPU 总线主控），参见图 (a) 和 (b)。首先，我们进行了不带 BARM 的基准测试以建立一组基线。随后，我们在启用 BARM 的情况下重复了这一基准测试（采样区间 32 ms）。其结果以相对开销的形式呈现。CPU 基准测试并未揭示任何显著开销。内存基准测试揭示了大约 3.5% 的开销。在线 CPU 核心数 / CPU 总线主控数对于开销没有影响。更进一步地，我们在使用不同的采样区间运行 BARM 时检查了其开销，参见图 (c) 和 (d)。同样，CPU 基准测试并未揭示任何开销。内存基准测试结果揭示了开销可以通过选择较长的采样区间而减少。较长的区间并不会阻止 BARM 检测 DMA 攻击。然而，较长的区间 _可能_ 意味着攻击者在其攻击被检测到并且被终止之前已经造成了某些伤害。

### 5.3.3 展示 BARM 的有效性的一个应用案例

即使我们并未在我们所呈现的概念验证实现中考虑平台上的全部总线主控，我们仍然可以展示 BARM 的有效性。这是可能的，由于并非所有的平台总线主控都是每一项敏感应用所必需的。例如，如果用户输入口令或者其他敏感数据，则只有 UHCI 控制器和 CPU 是必需的。我们利用 Linux 上的口令提示符评估了 BARM。我们设置了一组环境，当使用 `sudo` 或者 `ssh` 命令时，有 4 个总线主控是活动的（2 个 CPU，一个 UHCI 和一个 ME 总线主控）。BARM 与 `sudo` 或者 `ssh` 命令一同启动，并且在口令被输入时停止。BARM 终止了非必需的总线主控并且在口令提示符通过之后立即重启它们。我们利用我们自己的基于 DMA 的击键码记录器 DAGGER 攻击了此口令提示符，它执行于 Intel ME 之上，参见第 4 章。DAGGER 利用 DMA 扫描主内存以查找键盘缓冲区的物理地址，而这也是通过 DMA 被监控的。

> 图 5.8 利用口令提示符（`ssh` 命令）于运行时的任意时间点评估 BARM

> BARM 每隔 32 ms（采样区间）检查一次额外总线活动 _A_<sub>a</sub>。如果测量值高于容错值 _T_ = 50，则 _A_<sub>a</sub> 被发现。如果平台未被攻击，则这些值低于 _T_，参见图 (a) 和 (b) 之“无 DAGGER”。图 (a) 描述了这样一种攻击，在此，DAGGER 已经在等待用户输入口令。BARM 在首次测量时就检测到了 DAGGER 并且几乎立即将其终止。图 (b) 描述了 DAGGER 试图在运行时的任意时间点攻击平台，其结果类似。图 (c) 是在如图 (b) 所示的攻击企图过程中由 BARM 生成的内核日志。

图 5.8 (a) 可视化了当平台受到攻击时 BARM 所采取的措施。受到攻击意味着在用户被提示输入口令时，DAGGER 已经被加载。图 5.8 (b) 描述了平台在运行时的任意时间点受到攻击时 BARM 的处理结果。为了便于比较，图 5.8 (a) 和 (b) 还可视化了当平台未受攻击时 BARM 的测量结果。图 5.8 (c) 是内核日志的一部分，它确认了 BARM 是多么快地终止了 DAGGER。BARM 于时间戳 350.401045 s 检测到了 DMA 攻击。BARM 于时间戳 350.465042 s 识别了基于 DMA 的恶意外设。这项测试确认了 BARM 能够在攻击者造成伤害之前检测到攻击。当击键码记录器仍然处于搜索模式时，BARM 就终止了其攻击。这意味着击键码记录器并未找到键盘缓冲区。因此，攻击者不能捕获任何击键。我们将 BARM 配置为具有 32 ms 的 PMU 值采样区间。我们的评估揭示了在这段时间内，攻击者已经造成了超过 1000 次内存传输。这意味着我们甚至可以选择一个远大于 _T_ = 50 次总线传输的容错值。

## 5.4 当前的 BARM 实现的局限性

尽管对于当前的检测模型的实现的评估显示了 DMA 恶意软件可以利用可忽略的性能开销而被检测到，当前的实验仍然具有若干局限性。直到目前，我们只考虑了一个特定的 UHCI 控制器、一个指纹读取器、2 个 CPU 总线代理，以及一个 ME 外设作为总线主控（参见 5.3 节）。即使我们知道每一个总线主控都只能通过唯一的接口访问主内存，我们仍然不能排除这样的可能性，即当前用于此检测模型的方式不足以将所有可能的总线主控都整合进来。当前所整合进来的总线主控足以显示 BARM 可以检测到 DAGGER。此外，我们只考虑了某一代的 Intel 芯片组。这意味着关于其他世代芯片组以及其他厂商制造的芯片组的额外调查对于确定 BARM 在多大程度上普遍适用是必要的。

另一种局限性来自于我们利用一种 DMA 恶意软件范例来测试 BARM 这一事实。尽管 DAGGER 代表了典型的 DMA 恶意软件，即它必须在宿主内存中搜索有价值数据、并不要求同宿主软件进行任何合作，以及通过系统内存接口访问主内存，我们仍然不能排除可能有其他 DMA 恶意软件实现机制以绕过 BARM。例如，理论上对手可以试图利用每个采样区间（参见图 5.5）中的 2 _T_ 总线传输。这意味着对手可以隐藏多达 2 _T_ 的总线传输，如果有可能预测到非常精确的时刻，在此，BARM 认为 _T_ 是太少的总线传输。

然而，即使对手找到了某种方式以利用每个采样区间中的 2 _T_ 总线传输，这也会导致查找有价值的宿主数据的搜索阶段更加迟缓。这 2 _T_ 的总线传输明显少于在一个采样区间内通常可供对手使用的总线传输。与之相反，取决于在宿主内存中查找目标数据的搜索时间，宿主 CPU 可以利用延迟的搜索以进行例如重新安排内存地址空间等行动。这将会迫使对手重启搜索阶段。因此，BARM 应该利用额外的 DMA 恶意软件范例进行测试，以确认 BARM 也能检测除了 DAGGER 以外的 DMA 恶意软件。

诸如以太网控制器等总线主控可以试图绕过 BARM，通过 (i) 忽略将要通过 DMA 被复制的数据的源地址，以及 (ii) 利用由需要被复制以攻击宿主内存的数据长度决定的总线传输数量。源地址和长度是在例如宿主想要发送一个网络数据包时由宿主提供的。对手只需利用由此长度确定的总线传输数量。因此，BARM 不会检测到任何额外的总线活动，由于对手将非法总线传输伪装成了预期总线传输。此类攻击可以看作由网卡引导的中间人攻击。为了能够成功引导这种中间人攻击，攻击者还需要准确地确定预期的以太网控制器总线传输的数量。第 6 章呈现了如何考虑由网卡引导的中间人攻击。这一章还展示了正确的预期以太网控制器总线传输数量难于计算（相对于 UHCI 控制器）。因此，对手必须在计算预期的以太网控制器总线传输时考虑由此造成的潜在的性能开销。

## 5.5 本章小结

在本章中，我们展示了宿主 CPU 能够检测源自受到攻击的外设的额外的，即隐秘的和恶意的主内存访问，其基本理念是内存总线是一种共享资源，攻击者不能绕过它而攻击平台的主内存。这是攻击者的死穴，而我们则利用它来构建我们的检测模型。我们对通过宿主系统软件而获知的预期总线活动和实际总线活动进行比较。实际总线活动之所以可以被监测，是由于该总线是一种共享资源这一事实。我们开发了概念验证实现 BARM 并且利用最多 5 个总线主控评估了我们的方法，这其中包括现代计算机平台中最为重要的总线系统（PCIe、FSB、内存总线）。BARM 还可以在受到攻击的外设造成任何伤害之前将其识别出来并且禁用。

由于宿主 CPU 可以检测 DMA 攻击，我们得出结论，即宿主 CPU 可以防御自身而无需对固件或者硬件进行任何修改。平台用户不必须依靠诸如 I/OMMU 等预防性机制。我们选择实现一种能够永久监控总线活动的运行时监控策略。我们的监控策略考虑到了瞬时攻击。相关工作章节（参见 3.2 节）所呈现的反制措施，诸如签名固件和基于延时的证言等并未考虑瞬时攻击。与基于延时的证言方法，参见 3.2.3 节，相比，BARM 可以通过较少的努力而实现，并且无需关于外设的固件或者硬件的内部工作方式的知识细节。

我们同样鉴定了当前的 BARM 实现的局限性，诸如理论上可被利用的每个采样区间中的总线传输范围（2 _T_），或者某种由以太网控制器引导的可能的中间人攻击。BARM 不能检测由网卡实施的中间人攻击，而这可以被基于延时的证言方法揭示出来。这样的攻击也可以通过以某种可信信道 \[52\] 的形式应用端对端安全性来防止。我们在第 6 章采用可信信道的概念以使得 BARM 能够检测中间人攻击。此外，我们的 BARM 评估显示了性能开销是可忽略的。因此，我们得出结论，即我们的方法可以在实践中被部署。

