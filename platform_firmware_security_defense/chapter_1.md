# 第 1 章 简介

我们将会为您呈现一段关于现代平台固件技术的简介，从基于 Intel 的、基于 BIOS 的 IBM PC 开始。对于一位 IT 专家，这其中的某些内容可能是您已经知道的了。但是，我们会使其简短，然后前往讨论其安全启示。

平台固件已经经历了快速的进化和扩展，如同软件那样，它朝着更多层级的抽象和代码复杂度的方向发展。自然而然地增加了代码行数以及攻击面，这意味着同时有更多地东西需要防护。防护既包括认知又包括行动，而我们将会同时涵盖二者，对于系统管理员、站点可靠性工程师，或是企业事故响应蓝队（_Blue Team_）成员。

这些话题中的一部分对于个人消费者级别的固件防御同样相关，但是我们计划于近期发布一本专门探讨该话题的书。

## 1.1 定义平台固件

固件（_firmware_）这一概念拥有多种定义。对于移动/嵌入式/物联网设备，固件被认为是所有软件（操作系统和应用程序）。对于手机/相机/游戏机的固件更新正在迅速成为标准实践，并且如果这些设备被期望拥有互联网连接，它们通常包括使用互联网的自动或者半自动的更新能力。尽管比在操作系统中更新应用软件略为危险，在这些设备上的固件更新通常包括校验和以及多重引导程序能力以避免使得设备变砖。移动/嵌入式/物联网设备上的安全性是至关重要的，特别是由于它们通常持续暴露于基于互联网的攻击者。然而，这些固件实现中的很多过于复杂，以至于可以被看作独立的操作系统，通常是某种嵌入式版本的 Linux 或者某种 BSD 的变体。

与之相反，我们对于本书的目的是讨论诸如 UEFI、ACPI 和 PCI 选项 ROM 等平台固件。值得注意的是，任何复杂到同时拥有操作系统和应用程序的移动/嵌入式/物联网设备很可能不仅仅拥有一种固件，而是拥有若干种平台固件（_platform firmware_）用于板载的额外控制器或者处理器。例如，一台手机拥有一块主 CPU 以运行 Android 或者 iOS，但它同时拥有一块基带处理器用于运行固件。

平台固件是使得硬件能够工作的软件。诸如 UEFI、ACPI 和 PCI 选项 ROM 这样的名词是平台固件的组成部分。当硬件加电时，固件代码便被执行，该代码帮助初始化硬件。固件的引导程序加载操作系统，或者有时是下一层级的固件自举，最终导致操作系统的引导。大多数平台固件存储于闪存 ROM 芯片中。在某些案例中，例如 UEFI，固件也可作为来自文件系统中的文件（foo.efi）来加载，如同操作系统中的可执行文件（foo.exe）那样。

自原始的基于 BIOS 的 IBM PC 开始，平台固件已经发生了显著的进化。它已经变得更加复杂，极大地增加了攻击面，并且已经衍生为安装到任意给定的主板上的众多不同固件，而如果考虑外设则更多。不幸的是，每当平台固件更新可用时，即使是系统管理员有时也没能关注这些更新，因而它们从未被应用。有些固件实现是完全不可更新的，或是它们的空间限制使得必要的更新不能被应用。只有相对少数的平台固件实现拥有直接连接到互联网以获取更新的能力。即使某些实现诸如 UEFI 拥有完整的网络栈以支持网络启动以及诸如 BMC、IPMI 和 Redfish 等带外管理功能以支持远程管理，大多数实现仍然缺乏自动下载更新的能力。只有少数制造商和特定型号支持通过操作系统的自动更新机制来自动更新固件，例如 Windows Update 和 Linux Vendor Firmware Service，并且它们不全经过签名和加密。与之相反，即使是在今天，更新必须通过运行由各家固件提供商所提供的软件来实现，以检查状态并且按需应用更新。难怪平台固件更新会被忽略。

在本书中，我们将会探讨平台固件（_platform firmware_），并且可能会可互换地简称为固件（_firmware_）。

## 1.2 平台固件的类型

### 1.2.1 历史——从 BIOS 到 EFI

自从有 IBM PC 之日就有 BIOS 了，并且它仍然存在于某些现代系统中。BIOS 是用于 MS-DOS 的 16 位实模式代码库。大多数其他操作系统仅将 BIOS 用于初始化其自身，并且依赖于它们自身的驱动程序来访问系统。BIOS 是基于中断（_interrupt-based_）的，并且为操作系统/应用程序提供服务：中断 10h 为磁盘 I/O、中断 13h 为视频 I/O 等。IBM PS/2 拥有一种称为 ABIOS（高级 BIOS）的变体，它是一种保护模式的可重入（reentrant）的解决方案，解决了 BIOS 的众多原始技术限制，但是它专属于 PS/2 平台并且随着它一起消亡了。最初，BIOS 并没有包括任何安全考虑，然而随着安全性成为 PC 生态系统中的话题，BIOS 加入了口令，安全特性也开始被添加。在历史上曾经有过少数 BIOS 实现由 OEM 和 IBV（独立 BIOS 厂商）提供。UEFI 产生的原因之一是为了解决 BIOS 的技术限制。

ARC 是一种运行于某些 RISC 系统上的固件技术，包括 DEC Alpha、PowerPC、MIPS 等。ARC 的架构设计——固件可执行文件存储于 FAT 文件系统卷上——和 EFI 的设计非常相似。

### 1.2.2 EFI/UEFI

当 Intel 推出 Itanium 处理器的时候，EFI 作为其固件层被发明了出来，由于以 x86 为中心的 BIOS 不能运行于 Itanium 之上。其后，Intel 将 EFI 用作它的 x86/x64 系统上的除了 BIOS 以外的主要平台固件技术。当苹果从 PowerPC 迁移到 Intel 处理器之后，它们采纳了 EFI 作为其固件。微软 Windows 最终从 BIOS 迁移到使用 UEFI，并且后来强制要求 UEFI 用于 Windows。EFI 在朝向一种称为 Tianocore 的标准化、开源代码库的发展过程中变为 UEFI（统一 EFI）。UEFI 可以运行于 Intel 和 AMD 的 x86 和 x86\_64 系统上。UEFI 现在也可以运行于 ARM 系统上，并且出现在了某些 ARM 服务器上。UEFI 拥有一种有时会用到的架构独立的字节代码（EBC）。EFI 几乎没有安全特性，其后 UEFI 添加了安全启动（_Secure Boot_）（以及后来基于它的更多特性）和可执行文件的代码签名。

### 1.2.3 BIOS/UEFI 的扩展

#### 1.2.3.1 远程启动

某些早期的 PC 和终端机被作为“无盘工作站”出售，并且被设计为从通过网络远程加载的二进制文件来启动。这一功能被标准化为 PXE（预启动执行环境），并且被包含在众多 BIOS 系统中。由于 BIOS 仅针对本地启动而设计，这涉及到向固件中添加完整的网络栈和 NIC 驱动程序——可以是添加到 BIOS 本身之中，或是添加到 NIC 的固件中。当前的 UEFI 网络栈支持 IPv4、IPv6 和 iSCSI。除了 PXE 以外，UEFI 还拥有“UEFI HTTP\[S\] 启动”，即通过 HTTP 启动的能力。如果协议未被适当地防护并且认证，远程启动赋予了攻击者大得多的攻击面。

#### 1.2.3.2 ACPI

电源管理的不同固件解决方案，ISA PNP（即插即用）、APM 等已经进化为 ACPI。ACPI 被加入到 BIOS 中以启用电源管理，允许加电循环中的待机/唤醒状态。ACPI 同样也被 UEFI 使用，并且其 ACPI 规范由 UEFI 论坛控制。除了电源管理功能外，ACPI 是一种通用目的的固件扩展性的方法，厂商可以在其中定义它们自己的代码模块（表），其中包含了代码和/或数据。ACPI 拥有一种架构独立的字节代码（AML，即 ACPI 机器语言），因此每种操作系统都需要拥有 ACPI VM 以执行 ACPI 代码。微软 Windows PC 包括嵌入了 Windows 可执行文件的 ACPI 表，这些可执行文件将会在 Windows 需要 sysprep 或者恢复系统时使用。很多厂商拥有具有多样化用途的 ACPI 规范。修改社区已经长期更新 ACPI 表，以变通方式使得 Windows 或者 macOS 能够运行于不同的硬件之上。攻击者可以潜在地使用与修改者相同的技术以更新 ACPI 使其包含他们的恶意软件。

#### 1.2.3.3 PC 以外：嵌入式 Linux 引导程序

_U-Boot_ 和 _coreboot_ 是嵌入式 Linux 系统上的流行的引导程序。当使用在 Intel 系统上时，这些引导程序运行 BIOS 负载（payload）。coreboot 和 U-Boot 也能调用基于 UEFI 的负载——在 Intel 和 ARM 系统上。某些嵌入式解决方案将负载、coreboot 和 U-Boot 嵌套起来。更为复杂的是，传统的 UEFI 同样可以被构建为将 coreboot 用作 UEFI 初始化层（而非负载）。因此基于负载的引导程序可能拥有多种固件技术的组合。

ARM 可以运行 coreboot、U-Boot，或者较为罕见地运行 UEFI。以 ARM 为中心的两种固件安全技术的例子包括 _TrustZone_ 和 ARM 可信固件（_ARM Trusted Firmware_）。

Google Android 使用带有验证启动的 coreboot。Google ChromeOS 系统使用带有验证启动的 coreboot。在 Intel ChromeOS 系统上，coreboot 加载 BIOS 负载，而非基于 UEFI 的解决方案。尽管这种 BIOS 负载仅有有限的安全性，它正在受到 coreboot 的验证启动的保护。ChromeOS 通常使用 Intel 平台上的 TPM 或者 ARM 平台上的 TrustZone 作为支撑它的可信存储区。

### 1.2.4 CPU 以外：其他处理器

#### 1.2.4.1 TPM/fTPM

TPM 芯片被添加到某些 PC 上以提供可信根（_root of trust_），但是很多 BIOS 系统并未使用它。Trustworthy Computing Group 维护 TPM 标准以及相关协议。TPM 芯片被设计为存储难于访问的机密信息。除了基于硬件的 TPM 以外，还有固件 TPM（_firmware TPM_），这是一种软件（固件）实现，运行于另一块处理器之上，例如在 Intel ME 处理器上作为基于 Intel AMT 的固件而运行。据推测，任何托管固件 TPM 的处理器访问起来不会像防破坏（_tamper resistant_）的 TPM 那样困难。关于专用的 TPM 硬件的漏洞的一个近期的范例是 Infineon TPM 漏洞，称为 _ROCA_，它影响到具有弱密钥生成算法的特定芯片。某些整合了受影响的 Infineon TPM 芯片的厂商拒绝提供该 bug 的修复。

#### 1.2.4.2 管理处理器

Intel 将其管理引擎（ME）集成到 CPU 裸晶上一同发售，AMD 对其平台安全处理器（PSP）采取同样方式。苹果将其 T2 处理器作为一个独立组件发售。在每一种情况下，管理处理器可以运行应用程序，诸如用于提供远程管理能力（例如 Intel AMT）、fTPM 功能以及更多其他功能的应用程序。

#### 1.2.4.3 图形处理器（GPU）

图形处理器（GPU）被添加到 PC 中以提升视频性能。现在 GPU 被用作通用目的处理器（GPGPU）。某些高端系统拥有 GPU 阵列。通常，GPU 适配器通过 PCIe 连接（或者在某些情况下是雷电）。因此为了能够在启动时可见，它需要选项 ROM（_option ROM_）。

#### 1.2.4.4 网卡（NIC）

最初，PC 并不包含网络适配器，但是现在几乎每一台计算设备都至少拥有一块，通常是多块网卡。尽管某些网卡相对简单，某些技术诸如 TCP 卸载（_TCP offloading_）需要网卡拥有完整的通用目的处理器、相对复杂的固件以用于自举，有时还有完全扩展（full-blown）的操作系统以供操作。在蜂窝技术中，蜂窝网卡或者调制解调器包含强大的、通常是黑箱的固件，称为基带（_baseband_）。在此领域中包含并且考虑 WiFi、蓝牙和 NFC 技术是重要的，由于每种方式都提供了网络或者类似网络的方式以访问一台设备，并且可以使其默认打开或者拥有与之关联的平台固件。

#### 1.2.4.5 基板管理控制器（BMC）

基板管理控制器通常是独立于 CPU、内存、外存和网络的系统，被设计为管理主要宿主系统，通常用于刀片服务器。通常它们被设计为即使在宿主系统关机的情况下仍然保持开机，并且为系统管理员提供远程控制。BMC 是一个通用的词语，由很多品牌的实现，包括 IPMI、DMTF、SMASH、DASH 和 Redfish。历史上，这些控制器被构建为可以插到主板上的扩展产品，但由于它们的实用性，有类似 BMC 的特性被直接构建到 CPU 的主裸晶中——即使这意味着事实上是在主 CPU 内部附带一整套额外的 CPU 和操作系统——此种情况包括 _Intel ME_，尤其是作为应用程序运行于 Intel ME 和 _AMD PSP_ 之上的 _Intel AMT_。

#### 1.2.4.6 刀片服务器

当 PC 从台式机进化为服务器的时候，一个机架的刀片带来了一个新的信任级别。一个机架的多台刀片服务器在其机架上拥有一块服务处理器，它控制着刀片服务器，即作为所有刀片的新的可信根。控制了服务处理器的攻击者也就控制了所有刀片。

#### 1.2.4.7 智能手机

现代手机是具有平台固件以及嵌入的操作系统/应用程序的强大 PC。此外，手机还包括一块基带处理器及其固件。这些处理器及其固件通常是商业机密的闭源技术，因此很难说出如何才能防护它们。悲观的是，攻击者们很可能能够访问这些商业机密，因此可以使用该处理器来托管他们的恶意软件，而对于主系统的 CPU 和固件不可见。

#### 1.2.4.8 虚拟机监视器（Hypervisor）

防护一块轻信任何东西的裸机 CPU 不受攻击的一种方式是拥有一块后台管理模式处理器。另一种方式是将系统虚拟化，添加新的安全层级以对抗攻击者。有了虚拟机监视器，虚拟化的硬件现在包含了虚拟化的固件。与某些裸机目标相比，虚拟机监视器对于攻击者而言可能是更加容易的目标。其硬件和固件组件是操作系统级别的进程，磁盘上的固件相对于闪存上的更加易于访问，并且通常带有某种远程访问的方式而无需对于裸机系统的物理访问。对于防护者而言，针对 VMM 进程的攻击可能更加易于观察，利用操作系统级别的 SIEM 和记录工具，并且防护者至少会去关注操作系统级别的交互。

### 1.2.5 系统固件以外：外设固件

外设固件扩展了系统固件。当今，基本上有两类外设：插入主板插槽（ISA、ISA-PNP、EISA、PCMCIA、PCI、PCIe 等）中的板卡以及通过端口（USB、雷电、串口、火线等）连接的设备（硬盘、固态硬盘、监视器、打印机、扫描仪等）。二者之间的界限正在变得模糊，由于可以外接 PCIe 设备（通过雷电），并且有时可以跨过一个层级，例如直接连接到 PCIe 的 NVMe 设备就跳过了 SAS/SATA 层。微处理器（以及内存、ROM、NVRAM）的能力不断增加——低功率操作、更多的晶体管、更高的复杂度以及对于外设的需求的增加，因此更加强大的处理器（以及更多的内存、ROM 和 NVRAM）自然而然地被添加到所有外设中，随之而来的是更多行的代码以支持新增的特性，以及因此带来的更大的攻击面。

#### 1.2.5.1 PCIe 和雷电

当 BIOS 最初被开发之时，主要的外设板卡总线接口是 ISA，而现在则是 PCIe。当硬件厂商向它们的板卡（网络/磁盘/视频适配器等）中添加特性时，它们需要扩展 BIOS 所提供的那些特性。板卡通过选项 ROM，又称为扩展 ROM，即板卡所包含的用于扩展 BIOS 的固件来扩展 BIOS。BIOS 扩展其功能的方法是挂钩中断。雷电基本上是通过端口而非主板上的插槽的 PCIe，因而具有类似的选项 ROM 驱动程序的安全问题，并且对于攻击者而言，将设备连接到端口上相对于打开系统机箱向主板上添加板卡更加容易。

我们已经提到过 GPU 和网卡固件，但是 PCIe 适配器通过嵌入一块它们自己的 CPU 以试图从主 CPU 卸载工作量这一情形并不罕见。RAID 适配器也属于这一类别，然而任何具有足够高的数据吞吐量（或者足够高端/昂贵）的 PCIe 设备都属于此类候选者。

#### 1.2.5.2 USB

基于 USB 的设备拥有它们自己的固件栈。攻击者有多种方式来利用 USB 固件以使得 USB 设备以有趣的方式运作。USB 设备上的固件驱动程序可以声明其为网络设备、本地存储设备或是众多其他选项，这些选项可以使其骗过过于轻信任何东西的操作系统或是盲目地插入他人为其提供的 USB 设备的最终用户。

对于通过端口连接的设备，该设备包含固件，与此同时，现代的线缆（USB、雷电等）内部通常也包含固件。攻击者能够以带有多种攻击向量的方式将一块恶意 PCIe 或者 USB 设备连接到系统上：诸如 Hak5 USB Rubber Ducky 等设备是常用于 USB 的方法，而 PCILeech 是一种常用于 PCIe 的方法。最近的操作系统更新包括诸如在待机/唤醒状态下禁用端口的防护措施。

### 1.2.6 外设的外设

#### 1.2.6.1 存储设备

存储设备通常被连接到外设总线上，并且在系统侧有一块控制器，诸如 SAS 或者 SATA 主机总线控制器，或者 RAID 控制器，它们可能拥有其自身的固件。然而，每一块存储设备在其自身上也有固件。不幸的是，除了“控制器”以外还没有更好的词语用于这类事物。对于机械硬盘，其控制器必须能够将复杂并且可变的物理磁盘位置（块）映射到操作系统上的相对统一的逻辑块表示方式上来，并且通过标准化的 SAS 和/或 SATA 命令以及 SMART 管理协议进行通讯。固态存储设备作为一系列独立的闪存芯片来运作，因此除了映射块以及隐藏/重映射坏块以外，固态硬盘控制器通常也会实现 RAID 的一种内部变体以提供额外的数据恢复能力，以及管理一块可轮换的缓冲空间用于负载均衡。机械硬盘和固态硬盘通常还会加入诸如加密等特性。每一项新增的特性都需要额外的代码，从而增加攻击面。

## 1.3 防护引导程序

当系统固件尝试加载操作系统时，攻击者可以在不同时机利用 BIOS 或者 UEFI 系统。不同的技术被添加进来以帮助保护启动过程。

安全启动（_Secure Boot_）是 UEFI 的一项特性，它使用 PKI 来防护启动过程的某些阶段。如果禁用安全启动，用户可能会被诱骗运行基于 UEFI 的恶意软件或者不安全的操作系统。苹果的 macOS 不使用安全启动，但是提供了一种安全启动的变体，由于苹果已经在独立于 UEFI 发展它的 EFI。随着它们的 T2 安全处理器的引入，苹果引入了它们自己的安全启动，区别于 UEFI/EFI 安全启动。Windows 和 Linux 可以被配置为使用安全启动，并且微软已经强烈鼓励 OEM 迁移到 UEFI 2.x 以使用安全启动特性。UEFI 安全启动可以被配置为不仅保护启动过程，并且也保护内和扩展以及甚至是最终用户应用程序。在足够大的规模上，为您的企业考虑生成安全启动密钥是有意义的，并且将其保护完整地应用到应用程序的水平或许也是有意义的。

验证启动（_Verified Boot_）是用于 Android 和 ChromeOS 系统上的 coreboot 的一项特性，它在概念上类似于安全启动：如果验证启动被禁用，则攻击者可以暗中破坏启动过程。

测定启动（_Measured Boot_）使用 TPM 的测定功能以对启动过程的各个阶段进行散列值校验以期发现恶意软件。可信启动（_Trusted Boot_）使用 Intel TXT 的测定功能以对启动过程的各个阶段进行散列值校验以期得到类似的结果。

_Intel Boot Guard_ 是来自 Intel 的晶片级技术以在安全启动开始之前保护启动过程。一旦您在系统上启用 Boot Guard，您就不能再禁用它。

## 1.4 管理系统和固件

不同的技术被开发出来以帮助管理服务器系统而无需派遣 IT 员工前往数据中心。完全物理隔离的 IP-KVM 和 IP 电源开关解决方案可以变得更加安全，但同时也更加昂贵，因此对于可能需要远程管理的系统，（理论上）带外（_out of band_）但是完全集成式的解决方案被开发了出来。为了在一台系统看起来已经关机的情况下控制它，这些解决方案需要某些电源和网络访问，以使得管理处理器能够工作。通常，这些解决方案被集成到固件中或者与之邻近，或者属于非常低级的访问，事实上位于零环以下并且运行它们自己的固件，这具有相对较大的攻击面。

IPMI 是这一领域内的一种早期的标准化努力，以提供内建的或是通过扩展板卡提供的相对廉价的扩展的远程管理能力。关于 IPMI 的一个常见的安全问题是它通常在被制造商发售时处于启用状态，带有一个标准化的弱口令。尽管很多带有 IPMI 的设备拥有一块专用的管理网卡，随着该项技术已经变得廉价并且更加集成化，更为常见的是 IPMI 被启用于标准的主网卡上，或者甚至是可以轻松地被连接到非隔离网络的多个网卡上。

使用分开并且隔离的网络来进行此类管理几乎总是最好的实践，但是在某些情况下，这可能难于实现，特别是由于这些技术已经开始出现在台式机和笔记本上。

Intel 主动管理技术（AMT）是一种运行于 Intel ME 处理器上的固件，被设计为提供远程管理能力，并且被作为针对面向消费者的 CPU 的一项相对廉价的企业级升级选项而发售。AMT 提供了一种基于网络服务的远程管理系统。在最近发现的一个漏洞中，攻击者可以登录，而 AMT 的口令检查代码将会接受任何口令。制造于 2009 ~ 2017 年的系统存在漏洞，如果它们的 AMT 网络流量可以被攻击者访问，并且用于 AMT 的通常配置是将其设置为在主要的、一直在线的网卡而非隔离的管理网络上启用它。一个主要的漏洞也于近期被发现存在于 Intel ME 处理器及其自身的操作系统中。AMD 系统提供一种称为平台安全处理器（PSP）的类似技术。苹果于近期添加了一块 T2 处理器以为其 iMac Pro 和 MacBook Pro 提供某些类似功能。

DMTF SMASH 和 DASH 在某种程度上类似于 IPMI。多种 AMD 系统通常使用 DASH（用于台式机）和 SMASH（用于服务器）。

DMTF Redfish 是用于 IPMI 的一种标准化的替代方案，它提供了一种基于 HTTP 的 JSON ReSTful 管理接口。

还有众多类似的以厂商为中心的技术，诸如 HP iLO、Dell DRAC、Sun/Oracle ILOM、AMI MegaRac 等。UEFI 应用程序、驱动程序和服务也可以在 UEFI 引导程序加载操作系统之前运行。

## 1.5 总结

本章试图总结某些更为重要的计算机固件技术以及它们的某些安全问题。如需获得更多信息，参见 NIST SP 800-193 规范对于平台固件的列举，以及 CHIPSEC 项目的硬件抽象层驱动程序的组件（其中的每一个都是安全研究人员的一个兴趣领域）。计算机硬件和固件持续进化，并且涉及到多个层级的技术。攻击者正在学习使用固件作为他们的宿主，防护者需要学习保护他们的计算机固件。

