# 第 2 章 技术方法

有众多具有不同成熟度等级的方法展现出了对于减少软件漏洞数量的巨大潜力。此报告突出强调了其中 5 种足够成熟并且被证明为成功的方法，因此有可能将其外推到 3～7 年的视界中来。此列表的本意并非穷尽性，而是为了展示在减少漏洞方面取得显著进展是可能的，并且为了取得这一充满雄心壮志的目标铺平道路。SPSQ 研讨会的重要主题之一是这样一种需求，即不仅仅要改进软件，还要通过应用形式化技术来改进测试工具。

## 2.1 形式化方法

形式化方法包括基于数学和逻辑的所有软件分析方法，包括语法检查、类型检查、正确性证明、基于模型的开发，以及自动建构校正等。形式化方法可以帮助软件开发者取得关于整个类别的漏洞都不存在的更大的担保，并且还可能有助于减少不可预测的昂贵的测试和 bug 修复周期。

在编程的早期，某些实践者证明了他们的程序的正确性，即给定语言语义，他们从逻辑上证明了他们的程序具有某些属性或者能够得到某些结果。随着软件的应用爆炸式增长，以及程序变得如此之大，以至于单纯的手动证明变得不可行。形式化正确性参数不再流行。近几十年的发展，诸如由摩尔定律预测到的处理能力的激动人心的增长、多核处理器以及云计算，使得随时可用的计算性能增加了好几个数量级。用于求解布尔可满足性（SAT）问题、可满足性模数理论（SMT）\[Bjørner16\]、决策过程（例如有序二元决策图——OBDD）以及推理模型（例如抽象的解读和分离逻辑）等问题的算法的进展极大地削减了回答这些关于软件的问题所必需的资源。

关于使用形式化方法以实现大幅减少漏洞的早期努力之一是 20 世纪 80 年代美国国防部的可信计算机安全性评估判据（TCSEC）。TCSEC 详细叙述了多个层级的软件担保。其最高层级 A1 要求对于系统的形式化说明以及对于代码和说明之间的相关性的数学证明。成功的定理证明工具被开发出来，并且若干种经过形式化证明的系统被制造出来，但是实际使用所必需的代价和时间令人难以接受——多达 2 年。

到了 20 世纪 90 年代，形式化方法得到了这样的名声，即消耗太长太长的时间，不论是机时、人年还是项目时间，并且需要计算机科学的博士学位，还要懂得数学才能利用它们。现在的情况已经不尽如此。今天，形式化方法被普遍使用。例如，编译器利用 SAT 求解器以分配寄存器并且优化代码。操作系统利用形式化保证的算法以避免死锁。Kiniry 和 Zimmerman 称这些为“隐秘忍者式的形式化方法”\[Kiniry08\]：它们对于用户不可见，除非是报告某些东西不正确。与这些“不可见”的形式化方法的使用相反的是，显式的使用通常要求将问题重新呈现为某种与形式化方法工具兼容的形式。

显式形式化方法在机动车 \[ISO26262-6\] 和铁路 \[Boulanger15\] 标准中被推荐。形式化证明技术显著减少了取得由空运标准 DO 178B 所定义的目标所需付出的努力 \[Randimbivololona99\]。其继任者 DO 178C 拥有一整套补充：DO 333，它专门针对将形式化方法用于软件验证。大多数被提议的密码学协议现在经过模型检查器检查以查找可能被利用的漏洞，并且分析者可以执行实现了密码学算法匹配规范的几乎完全自动化证明 \[Carter13\]。实践者们还利用模型检查器以查找网络中的攻击路径。

抛开它们的长处，如果对于软件要求没有明确的声明，或者到底是哪些东西构成了恰当的软件行为这一点只能通过人类判断或者平衡众多相互冲突的因素来确定，则形式化方法不那么有效。因此，我们将不会期待形式化方法对于评估用户界面的可用性、部署探索性的软件，或者非结构化的问题作出那么大的贡献。

形式化方法包括软件开发的所有阶段以及众多不同应用领域的众多技术，我们不能列出每一种潜在地有帮助的形式化方法。与之相反，我们专注于可能在中期作出显著贡献的少数方法。

### 2.1.1 可靠的静态程序分析

静态分析是在不执行软件的情况下对其特定属性进行检查的过程。出于我们的目的，我们只考虑自动化的分析。启发式分析比可靠性分析更快，但是缺少来自于逻辑推理链的担保。有些问题只能通过在分析的条件下运行软件，即通过动态分析来回答。结合静态和动态分析将会得到一种混合技术。特别地，通过执行软件可以得到关于那些不能仅仅利用静态技术来确认的属性的存在性证明。

软件的众多呈现形式（例如系统要求、架构、源代码和可执行文件）可以进行静态分析。然而，源代码分析是最成熟的。源代码分析的优势之一在于，在源代码中识别出来的问题的上下文可以通过熟悉的呈现形式传递给软件开发者：代码本身。如果其他呈现形式被分析，则需要额外的步骤以将报警信息转化为某种形式，人们可以首先理解它，并且随后将其与分析中的程序相关联。

根据 Doyle 的评估，可靠的静态分析在覆盖度、可缩放性和付出努力的回报等方面均优于当前的软件开发实践 \[Doyle16\]。我们相信其限制之一是某些属性难于通过可用的概念来叙述。

形式化描述和可靠的静态分析在近年来已经展示出显著的适用性。例如，Tokeneer 项目展示了利用形式化方法开发软件比传统软件开发技术更快、更廉价，并且具有更少的 bug \[Barnes06, Woodcock10\]。TrustInSoft 利用 Frama-C 以证明 PolarSSL 中不存在一系列通用缺陷列表（CWE）中的类，它现在称为 mbed TLS \[Bakker14, Regehr15\]。Ourghanlian 比较了 PolySpace 验证器、Frama-C 和 Astrée 的应用以评估核电站中的安全关键软件 \[Ourghanlian14\]。可靠的静态分析和其他形式化方法被广泛应用于不限于交通运输、航空航天、核电站控制等领域的软件开发 \[Voas16b\]。

这些进展体现出了静态分析的众多应用中的少数。更进一步，静态分析拥有这样的潜力以有效地排除新开发的软件中的若干类错误，并且减少与通过测试达到更高层级的担保所需资源相关的不确定度。

### 2.1.2 模型检查器、SAT 求解器和其他“轻量级”决策算法

这些算法可以解答关于理想的更高层级属性的问题，诸如某个协议仅在某人拥有某个密钥的情况下允许读取敏感文本、安全属性由系统预留、某项赋值满足多个限制条件，或是没有途径通过（已知的）攻击进行突破。这些算法也可以被应用于分析具体的设计产物，诸如有限（以及无限）状态机。

Doyle 的评估结论是，模型检查器可能拥有优异的覆盖度，很多属性可以被呈现 \[Doyle16\]。然而，由于所需的努力随着问题大小呈指数增加，总会有某个事实上的大小限制。小于该限制的问题可以被快速求解。非常大型的问题可能要求额外的资源或者密集的人力以便将此问题分解为合理的部分。

这样的技术实质上可以通过两种方式应用。其一，它们可以被用作生产中的软件的一部分。例如，与其使用某种临时安排的程式以便为一台运输卡车查找一条高效的路径，某个应用程序不如使用已有深入研究的旅行推销员或者生成树算法。其二，可能也是与此报告的主题更加相关的方式是使用这些方法来设计或者验证软件。

### 2.1.3 断言、先决条件、后置条件、不变量、切面和契约

程序员通常拥有一个信息体以为其提供关于软件将会按照预期执行的信心。形式化方法中的一个被忽略的部分是无歧义地记录这些洞察力。变量拥有不同的术语，诸如契约、断言、先决条件、注释、后置条件和不变量等。这可能会使得程序员花费额外的思考以使用某种类似于代码表达式的语言来精确地叙述将会发生什么，但是这样地声明是会带来帮助的。诸如由反例指导的抽象详细化（CEGAR）等自动化辅助工具可以帮助生成声明。这些声明在开发和测试过程中被激活（“编译进来”），然后可以在发布之前取消激活。

这种方式的好处是，关于代码中具有的属性的形式化声明可以被用于对代码进行交叉检查。例如，测试可以通过断言直接生成。它们可以被激活以便在测试或者生产过程中执行内部一致性检查。由此可以使得错误被检测出来的时间大大提前，并且距离出错的代码更近，而非不得不从外部可见的系统故障进行回溯。基于断言的测试可以检测出具有适当的覆盖度水平的输入空间中的多达 90% 的错误 \[duBousquet04\]。这样的声明还提供了额外的信息以执行关于程序正确性的半自动的证明。与在代码更改时不会被更新的注释不同的是，这些声明可以被计算机证实或者强制实施，并且因此必须持续成为关于程序特性和属性的准确声明。

关于这样的形式化声明可以如何带来帮助的一个令人印象深刻的例子是 1996 年的阿丽亚娜-5 运载火箭首次发射失败。阿丽亚娜-5 使用了来自取得成功的阿丽亚娜-4 的软件。当阿丽亚娜-4 被设计之时，分析显示 16 位整数能够处理其速度。然而，阿丽亚娜-5 的更高的速度使得该变量溢出，导致计算机关机以及运载火箭失事。如果其代码拥有关于其速度必须能够适配进 16 位整数的先决条件，“任何称职的团队将会检查……\[此先决条件，它\] 将会立即提示阿丽亚娜-5 的调用软件并不满足它所调用的阿丽亚娜-4 例程的预期” \[Jézéquel97\]。

### 2.1.4 自动建构校正和基于模型的开发

在基于模型的开发中，软件开发者创建并且修改系统的模型。其行为可以在某种更高级或者领域特定的语言或者模型中说明，随后其代码被自动生成。大部分或者全部代码是从模型生成的。这是一种自动建构校正技术。此技术和诸如详细化设计等其他技术致力于完全避免整类漏洞，由于开发者极少接触代码。与此类似的代码合成相对于其他形式化方法适用于较少的情况，由于这对于为某些领域开发建模超结构和代码生成器是不可行的，例如，某种具有错误恢复和帮助提示的用户界面。这样的模型或者规范还可以生成测试套件或者准则。它们还可以被用于验证或者监视系统运行。

如果分析者能够指定整个系统，或者哪怕只是子系统的完整的高层级模型，我们就称此模型为“领域特定语言”（DSL），并且不再认为它值得一提。这代表了形式化方法的一种实质性的应用。根据 Doyle 的评估，程序合成在覆盖度方面等级为“A+”，而在努力和属性方面等级为“B”\[Doyle16\]。

### 2.1.5 经过验证的工具和代码目录

软件开发者通常必须花费大量努力以便将具有已证明的属性的工具或者开发程序认定为合格。即使如果后期的开发者想要使用这样的工作成果，也没有中央结算机构可供咨询。关于经过验证的工具、精心构建的库，甚至是可重复使用的规范和要求都能够加速形式化方法的采用。这样的工具库可能有助于具有显著减少的漏洞数量的软件的更宽泛使用，并且具有随之而来的担保。

众多企业和政府机构评估用于类似用途的相同的工具或者软件。由于可能难以发现谁已经完成了相关评估，每一家实体都必须重复此工作，有时它们的知识和细致程度还不如其他实体已经投入的。这特别具有挑战性，由于众多合同条款阻碍分享成果 \[Klass16\]。一份库或者列表将会带来巨大利好。一旦得知相关的努力成果，开发者可以为一项努力成果作出贡献，而非从事他们自己的努力。作为某个库的代码或者“即时”实例化成果，开放式网络应用程序安全计划（OWASP）基金会协调组织了一个项目以开发一个囊括了关键安全性操作的应用程序接口（API），它称为企业安全性 API（ESAPI）。

参见 2.4 节以获得关于经过良好测试和良好分析的代码的重复利用的讨论。

### 2.1.6 网络加固：使形式化方法发挥作用

上述技术可以被用于开发软件，然而，重制所有遗产软件是不可行的。这被称为“网络加固”，以同旨在获得对于地震的更高抵抗力的“抗震加固”相类比 \[Fisher16\]。第一步是识别现存系统中最具决定性、关键性或是基础性的组件。SPSQ 研讨会参与者还强调了将形式化方法用于关键模块而非整个应用程序。除了基于目的编写的代码以外，关键组件还可以是编译器或者运行时库。这些组件随后利用适当的形式化方法仔细检查或者重建以获得更高层级的担保，如同在 PolarSSL 中所进行的，它现在称为 mbed TLS \[Bakker14, Regehr15\]，继 Heartbleed 或者 CompCert 验证 C 编译器之后 \[Leroy06\]。

网络加固中的另一个小步骤是在具有自动强化或者加固的情况下重新编译组件。例如，编译器可以在每当可能时对所有的内存访问添加边界检查，以极大地减少未被识别的缓冲区溢出（BOF 类）的数量 \[Bojanova16\]。这样的强化几乎没有任何性能影响 \[Flater15\]。编译器还可以利用更为安全的“加强”函数来替换典型的不安全函数，并且可以利用可执行空间保护，例如将用于数据的内存区域标记为不可执行。

### 2.1.7 成熟度水平

今天，形式化方法在全世界被使用，通常是相对地隐秘的。最为普遍的应用之一是现代编程语言中的强类型检查，这是一种形式化方法。其他尽管有限的应用包括不同软件检查工具的算法，它们中的某些被构建到广泛使用的开发环境中（例如标记出对变量的不一致使用、缺失的值或者不安全接口的使用）。在 2010 年，澳大利亚国家信息通讯科技卓越研究中心（NICTA）的研究人员展示了对于包含约 10000 行 C 代码的 seL4 微内核的形式化验证 \[Klein14\]。英国国家航空交通服务控股公司（NATS）的临时未来领域控制工具支持（iFACTS）包含超过 200000 行 SPARK 代码，并且“所有代码更改 _必须_ 被证实为良好，然后代码才能被提交”\[Chapman14\]。

### 2.1.8 可信度的基础

断言、契约、不变量以及其他形式化声明在高质量软件中已经得到大量采用。它们之所以得到逐渐改进以涵盖更多高级条件和 API 检查，是由于它们已经在开发者社区中证明了自己的价值。例如，源代码注释语言（SAL 2.0）在微软 Visual Studio 2015 中可用。众多工具现在可以执行静态分析。一种自然的发展趋势是不断提升更多高级形式的静态和混合分析。基于诸如先决条件和后置条件的满足性以及随码证明等技术的软件证明已经在关键软件中开始得到采用 \[Souyris09\]。它们要求更多的努力和成本，然而，在某些案例中，它们被证明为在长期具有成本高效性：在 1/3 的应用中具有开发时间和成本方面的改进，而对于已部署的系统只需较少的修补甚至不需要修补 \[Woodcock09\]。

### 2.1.9 潜在影响的基本原理

最大的潜在影响可能在于避免了那些随着时间演进会被严重依赖的组件的成本。Heartbleed 漏洞是一个例子，关于较小的代码基具有过大的重要性：对于形式化方法的明智使用可能会在一上来就避免此问题。通常，诸如那些可以利用形式化方法制造的高质量软件可以被用于降低软件组件的长期维护和替换成本。不像物理系统那样发生磨损并且最终失效，软件系统只会在它们本身不正确，并且其瑕疵被诸如特定的输入序列或者组合等环境因素触发时才会失效 \[Woody14\]。

### 2.1.10 延伸阅读

* \[Armstrong14\] Robert C. Armstrong, Ratish J. Punnoose, Matthew H. Wong and Jackson R. Mayo, “Survey of Existing Tools for Formal Verification,” Sandia National Laboratories Report SAND2014-20533, December 2014. Available: [http://prod.sandia.gov/techlib/access-control.cgi/2014/1420533.pdf](http://prod.sandia.gov/techlib/access-control.cgi/2014/1420533.pdf) Accessed 12 October 2016.
* \[Chapman14\] Roderick Chapman and Florian Schanda, “Are We There Yet? 20 Years of Industrial Theorem Proving with SPARK,” in _Proc. Interactive Theorem Proving: 5th International Conference, ITP 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 14-17, 2014_. Gerwin Klein and Ruben Gamboa, Eds., _Lecture Notes in Computer Science_, Vol. 8558, Springer, 2014, pp. 17-26, [https://doi.org/10.1007/978-3-319-08970-6_2](https://doi.org/10.1007/978-3-319-08970-6_2).
* \[Voas16a\] Jeffrey Voas and Kim Schaffer, “Insights on Formal Methods in Cybersecurity," _IEEE Computer_, Vol. 49, Issue 5, May 2016, pp. 102–105, [https://doi.org/10.1109/MC.2016.131](https://doi.org/10.1109/MC.2016.131). 7 位形式化方法专家的立场.
* \[Voas16b\] Jeffrey Voas and Kim Schaffer, “What Happened to Formal Methods for Security?”, _IEEE Computer_, Vol. 49, Issue 8, August 2016, pp. 70-79, [https://doi.org/10.1109/MC.2016.228](https://doi.org/10.1109/MC.2016.228). 同上述 7 位专家的关于形式化方法的后续圆桌会议.
* \[Woodcock09\] Jim Woodcock, Peter Gorm Larsen, Juan Bicarregui and John Fitzgerald, “Formal Methods: Practice and Experience,” _ACM Computing Surveys_, Vol. 41, Issue 4, October 2009, pp. 1-36, [https://doi.org/10.1145/1592434.1592436](https://doi.org/10.1145/1592434.1592436).

## 2.2 系统层级的安全性

当软件被执行时，用于该运行着的软件的系统上下文定义了可用于该软件的资源、访问这些资源所需的 API，以及软件可以如何访问外部实体（以及被它们访问）。系统上下文的这些方面可能会强烈影响以下内容：软件包含漏洞的可能性（例如复杂或者有 bug 的 API 将会增加这种可能性）、攻击者利用漏洞的可能性（例如系统服务越容易从外部接触，这种可能性就越大），以及攻击可能具有的影响（例如，对于系统资源和具体任务成本的损害）。

长期以来，系统设计者的目标之一是设计出对于攻击具有抵抗力，并且对于程序和用户都能强制实施理想的安全策略的系统。自 1965 年开始的多任务信息与计算系统（Multics）\[Corbato65\] 结合了若干种理念（例如虚拟内存、多进程和内存段等）以实现一种计算工具，它能够保护信息以防止非授权访问。自 20 世纪 70 年代开始，若干种安全策略模型被引入以使得系统层级的安全责任形式化。在 1976 年，Bell-LaPadula（BLP）模型 \[Bell76\] 提供了关于保护分级信息的强制安全性的形式化表达：BLP 模型允许“高”（例如 SECRET（机密））进程访问“低”（例如 UNCLASSIFIED（未分级））信息以获得可用性，但是禁止“低”进程访问“高”信息。 Goguen 和 Meseguer 的无干扰模型解释了间接信息流，又称为隐秘信道 \[Goguen84\]。Biba 的完整性模型表述了关于完整性的强制安全性：它禁止可能是恶意（低完整性）的数据被高完整性的进程观察到，由此降低高完整性的进程和数据可能发生损坏的风险 \[Biba71\]。Boebert 和 Kain 的类型强制模型提供了一种基于表格的访问控制机制，它只允许数据被预先批准的程序转换 \[Boebert85\]。这些模型为理想的安全属性提供了必要的明确性，但是，在真实尺度的系统中使用这些模型为系统管理员带来了可用性的问题，并且这些模型的软件实现仍然包含可被利用的瑕疵。

在 1999 年，美国国防高级研究计划局（DARPA）启动了建立在这一理念之上的入侵容忍系统（ITS）项目，即系统可以被构建为能够继续运作，或者“容忍”哪怕是成功的攻击。随之而来的若干其他研究项目也基于此理念而构建 \[Tolerant07\]。由这些项目探索的基本概念包括具有冗余和多样化的组件的系统构造，它们不太可能被单一漏洞全部破坏、新的策略强制执行软件层的引入，以及用于自动恢复的诊断推理组件的应用。深入容错系统的 DARPA 研究意识到，从真实世界的系统中消除所有漏洞对于可预见的将来是不太可能实现的。这些研究展示了在红队测试中的实质性容忍（例如参见 \[Chong05\]），但是这些方法同样施加了显著的配置复杂度、降低的执行速度和显著增加的资源（CPU、内存等）要求。

最近的软硬件进展带来了这样的可能性，即开发出对于性能和成本都很高效的安全性强制执行和入侵容忍系统。这样的系统拥有抑制软件漏洞所能造成的危害的潜力。在硬件方面，低成本的多核处理器和系统芯片正在降低实现冗余度的成本。在与之互补的软件方面，新兴的架构结构正在带来新的机会以便将安全性和容错性构建到下一代系统中。在众多可能的结构中，两种看起来有前途的结构是操作系统容器和微服务。

### 2.2.1 操作系统容器

“容器是为了运行于其中的应用程序或者系统而隔离宿主的某些资源的对象。”\[LXC\] 从实质上讲，容器是一个非常轻量级的虚拟机，其资源（内存、硬盘和网络等）可以同宿主计算机或者其他容器进行非常灵活的共享。容器提供了独立计算机或者完整的虚拟机的某些隔离属性，但是，容器可以在商品级硬件上在几分之一秒的时间内启动。容器通常要求显著少于完整虚拟机的计算和存储资源。

基于容器的隔离可以明显减少软件漏洞的影响，如果隔离足够强。因此，获取关于容器基础设施组件（例如 Linux 内核中的控制组和名称空间）在面对恶意输入时是强壮的这一点的担保至关重要。容器用户需要对这些组件进行建模、分析、测试和验证以构建关于容器配置能够按照预期运作的担保。

尽管容器可以非常轻量和灵活，这种灵活性的代价是容器配置的复杂性，这决定了容器中的众多关键元素，诸如它如何共享其资源、它的网络栈如何配置、它的初始进程、它所能够使用的系统调用等等。尽管市场已经接受了支持共享容器配置的管理系统，诸如 Docker \[Docker16\]，仍然需要这样的工具和技术，它们可以分析容器配置并且确定它们能够在多大程度上降低安全风险，包括能够在多大程度上化解软件漏洞的效果。

此外，容器带来了机会以应用某些传统安全性模型以及入侵容忍技术，利用有利于效率和部署的简易度的构建块。现在有了新的机会以重新评估哪些高级安全性模型和入侵容忍技术能够成为主流技术。

更进一步地，由于容器可以围绕某个程序的单次运行而有效地封包起来，容器可以被配置为仅仅授予某个程序对资源的最小访问级别，并且由此遵守最小权限原则 \[Saltzer75\]。最小权限原则是关于限制软件漏洞和攻击的效果的基本原则。然而，想要具体说明某个程序所要求的最小资源这一点是众所周知地困难的。与其试图在其完整的普遍性之中求解该问题，不如采用某种策略以开发分析技术和工具，以便生成自定义的容器配置，该配置能够近似重要程序类别的最小权限。由于部署容器的相对简易性，这样的工具辅助容器能够为主流系统带来显著增加的访问控制有效性和安全性。

### 2.2.2 微服务

微服务描述了“一种将软件作为一套小型服务来设计的方式，每个服务运行于其自身的进程之中，并且通过轻量级的机制进行通讯。”\[Fowler14\] 核心的微服务理念并非最新的：它已经被人们利用网络服务以及在基于微内核的操作系统中探索过了。这些方法包括 Mach 微内核 \[Rashid86\]、GNU Hurd \[Hurd16\]，以及网络服务架构 \[WSA04\]。然而，微服务方法根据不同的判据来构造服务。微服务应该实现单个业务（或者任务）能力、拥有独立的刷新循环、替换起来相对简单，并且对于编程语言不可知 \[Fowler14\]。简而言之，每一个微服务都应该具有其自身的经济和管理意义。与此同时，微服务可能彼此依赖，这可以支持具有良好定义的模块性。

这种系统结构方式可能产生若干组件，其接口被显式定义，并且其依赖也被类似地显式定义。

随着系统运行以及控制流在微服务之间传递，有一种自然而然的激励以使得服务间通讯“批量化”，从而分担跨边界的开销。尽管这种批量化在某些情况下可能会增加延迟，它也能够简化组件间依赖，并且可能减少发生软件瑕疵的可能性，进而减少漏洞。

将软件作为微服务的集合来部署带来了一个基本问题：构建一种“可信微服务”是否有意义？更加具有雄心壮志的问题是，开发出能够作为其自身的引用监视器的微服务是否可行？引用服务器的概念始于 1972 年的 Anderson 报告 \[Anderson72\]，并且指的是一种系统组件，它对于其所提供的资源的所有访问进行调度。引用监视器具有以下特点：1) 总是被调用；2) 防破坏；以及 3) 经过验证（即它足够小，以便被构建为具有高度担保）。随着微服务变得越来越流行，现在可能正是时机以研究制定关于可信的或是能够作为引用监视器的微服务的判据，以及理解微服务的架构结构的安全局限性。

通过使得组件依赖和相互作用更加显式化，微服务看起来带来了新的机会以实施基于干涉的安全增强。插入到这些微服务相互作用之间的封包层将会拥有能力以增强、转换、拒绝以及监视这些相互作用。这些能力可以被用于限制来自软件漏洞的潜在危害，但是，干涉也可能导致系统不稳定并且带来性能下降。一种可能的研究介入是调查与基于微服务的系统兼容的干涉策略。微服务提倡组件之间的简化接口（例如没有通过全局状态的内存共享）。这种简化可能使得基于微服务的干涉在执行时具有较少的与稳定性相关联的效果。

### 2.2.3 成熟度水平

虚拟化系统可以追溯至 20 世纪 60 年代。LXC 容器形式的虚拟化始于 2008 年，并且自此处于活跃开发之中。也存在若干替代的轻量级虚拟化系统，例如 BSD Jails、OpenVZ 以及 Oracle Solaris Zones。容器已经被实质性地部署于云端和服务器上。\[脚注 1\]

当前的微服务术语和设计目标出现于 2014 年。早期的表述方式，诸如运行于微内核之上的任务，可以追溯至创始于 1985 年的卡内基梅隆大学的 Mach 项目。自此以后，微内核技术成为了后续研究的主题，并且被整合进了大型商业产品，尤其是苹果 OS X。

> \[脚注 1\] 操作系统容器有助于实现某些云机制，但是云计算完全不同于操作系统容器 \[Mell11\]。

### 2.2.4 可信度的基础

基本技术已经被广泛应用，并且对于容器配置的更多自动化有着公认的需求，因此会有需求拉动。由于容器可以被非常快速地创建、测试和删除，已有确凿的证据显示关于容器配置的大范围测试可以通过半自动的方式进行。关于微服务，微服务框架的数量的增长提示该技术的流行度正在增加，并且仍然有空间以进一步丰富微服务框架，以及使得这些新增的框架被采用。同时，微服务的模块化本质可能为部署更多安全版本的微服务而不会显著干扰对用户的服务提供道路。

### 2.2.5 潜在影响的基本原理

操作系统容器和微服务已经是国家信息基础设施的重要组成部分。鉴于使用它们所具有的明确的可管理性、成本以及性能方面的优势，有理由期待它们的应用持续扩展。这些技术的安全增强版本一经采用，可以对软件漏洞的利用行为产生广泛的抑制效果。

### 2.2.6 延伸阅读

* \[Fowler14\] Martin Fowler, “Microservices: a definition of this new architectural term,” 25 March 2014. Available: [http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html) Accessed 13 October 2016.
* \[Lemon13\] Lemon, “Getting Started with LXC on an Ubuntu 13.04 VPS,” 6 August 2013. Available: [https://www.digitalocean.com/community/tutorials/getting-started-with-lxc-on-an-ubuntu-13-04-vps](https://www.digitalocean.com/community/tutorials/getting-started-with-lxc-on-an-ubuntu-13-04-vps) Accessed 13 October 2016.
* \[What\] “What’s LXC?”, Available: [https://linuxcontainers.org/lxc/introduction](https://linuxcontainers.org/lxc/introduction) Accessed 13 October 2016.

## 2.3 附加软件分析技术

当前存在众多不同的工具和技术，既有开源软件又有私有软件，用于分析软件以及检查大量问题。它们中的很多可以通过诸如 Eclipse 等通用集成开发环境（IDE）来执行。但是，当前的工具面临若干种阻碍。IDE 有时并不会为工具提供某种“信息总线”以共享软件属性。每一种工具必须进行其自身的语法检查、构建其自身的抽象语法树（AST）、列出带有其范围和属性的变量，以及利用经过证明的事实或者不变量来“装饰”AST。有些工具基于通常的基础设施而构建，诸如 LLVM 或者 ROSE \[Rose16\]，因此它们共享代码，但是它们仍然必须重复进行大部分分析工作。此外，几乎没有标准以允许，例如，一种语法检查器被替换为运行得更快的新的语法检查器。

附加软件分析指的是一种完备的方法以解决使用多种高级软件检查工具时遇到的阻碍。附加软件分析的目标是促成高度可用的分析模块的持续积累，这些模块随着时间不断累积，以持续改进部署于软件分析中的最先进的实践。附加软件分析分为 3 部分。其一，它是有文档记载的标准以允许算法和工具交换关于软件的信息。其二，它是一个框架或者架构以允许软件担保和评估工具的模块化和分布式开发。此框架拥有类似于知识发现元模型（KDM）\[KDM15\] 或者在人工智能（AI）中称为黑板的功能。其三，它是概念性的方法以聚合、相关或者分析工具和算法的结果和能力。附加软件分析的一项关键输出将会是新一代面向用户的工具，它们可以便捷地将来自不同工具和技术的输出整合起来，形成关于某一软件的统一的、更加完整的评估。

完整的附加软件分析能力必须辅助工具协同工作、提供构建块以强力推动新的工具开发，以及辅助工具之间的整合和互操作性。因此，它必须包含标准、框架和技术以合并分析结果。

### 2.3.1 软件信息表达与交换标准

软件担保工具推导并且存储关于程序的五花八门的信息。然而不幸的是，并没有被广泛接受的标准以用于信息的精确定义或者它们可能被如何存储。由于缺少标准，开发者必须执行英雄壮举以便在不同的分析工具和算法之间忠实地交换信息。

仅仅在工具之间往返传输位几乎不会带来任何好处，除非这些位传达了被各种工具以相同方式理解的信息。例如，“error”（错误）、“fault”（故障）、“failure”（失败）、“weakness”（弱点）、“bug”和“vulnerability”（漏洞）是相互关联但是各不相同的概念。如果没有标准，一个工具报告了某个 bug，而另一个工具可以将“bug”理解为指示相对于第一个工具的评估结果更高（或者更低！）的成功攻击潜力。

例如，一系列形式化定义的信息可能对于分析某个程序是相关的：

* 在代码中的位置
* 在某个特定位置可见的变量，以及变量类型
* 在某个特定位置的可能的变量的值，这可能包括变量的值之间的关系，诸如 `x < y`
* 调用轨迹和路径，即到达这一点的所有可能路径
* 对于二进制文件和可执行文件块的源代码位置引用
* 可能的弱点，例如可能的 BOF \[Bojanova16\] 或者将要用于 SQL 查询的未经过滤并且因此受到污染的输入
* 断言、最弱的先决条件、切面、不变量等，以及
* 函数签名，包括参数类别

程序分析可以被应用于软件开发的不同阶段，并且被用于程序在不同抽象层级上的表现形式。例如，工具可以运行于程序的静态结构，诸如其 AST 之上，也可以运行于呈现数据或者控制流的表现形式之上，甚至还可以运行于编码功能行为，诸如最弱的先决条件的语义表现形式之上。我们接下来依次查看这些类别中的每一种。

**抽象表示**：早期的静态检查器通常不得不包括其自身的用于构建 AST 的语法检查器以进行分析。然而，编译器编写者意识到了开发具有良好的文档并且可简易访问的通用中间表示（IR）的重要性。例如，GNU 编译器 gcc 的开发团队在 4.0 版本 \[GCC16\] 中引入了中间语言 GENERIC，这是一种语言独立的格式，用于以若干种语言中的任何一种来呈现源程序。作为另一例子，Clang 编译器 \[Clang\] 提供了一种具有良好文档的 AST，它可以由第三方插件直接访问，也可以被保存为某种通用格式，诸如 JSON，以便被第三方分析工具处理。其他提供了具有良好文档的转换格式的编译器包括 Frama-C \[FramaC\] 和 ROSE 编译器基础设施 \[Rose16\]。

**中间表示**：工具可以对距离由编译器生成的最终可执行代码更近的中间表示（IR）执行深度分析。例如，GNU 编译器定义了 GIMPLE 格式，其中原始源程序被分割为简单的三地址语言。类似地，Clang 编译器提供了 LLVM 位代码表示，这是一种有类型的汇编语言格式，并不依附于某种特定的处理器。其他的包括通用中间语言（CIL）\[ECMA12\] 和 Java 虚拟机指令集或者字节码 \[Lindholm15\]。Vine 中间语言是一种平台独立的机器语言 \[Song08\]。

**语义表示**：用于检查功能正确性属性的工具通常需要这样一种表示形式，它比上文讨论的表示形式更加适合于表达逻辑程序属性。尽管这样的表示形式不如 AST 以及编译器 IR 那样成熟，其中的少数已经于近年获得了流行度。例如中间验证语言 Boogie \[Barnett05\]，它提供了诸如参数多态、全称量化和存在量化、不确定性选择，以及部分有序等特性，并且已经成为高级检查器的流行后端，既可用于诸如 C 和 C++ 等低级语言，又可用于诸如 Eiffel 和 C# 等高级面向对象语言。Boogie 程序可以被翻译为 SMT-LIB 格式 \[SMTLIB15\]，这允许它们被任何支持 STM-LIB 格式的定理证明器检查。将通用语言用于语义表示的另一个例子是 Datalog \[Whaley05\]，它已经被用于构建不同的工具以检查数组边界溢出、在多线程程序中查找竞争条件，以及检查网络应用程序安全性等。

### 2.3.2 工具开发框架或者架构

为了促成新工具的开发，附加软件分析要求初始构建块。关键的初始构建块是一种框架，它能够将工具或者技术的能力结合起来。正如 Eclipse 极大地促进了用于开发代码的 IDE 技术的改进那样，附加软件分析的框架将会致力于使得软件担保和测试工具的协同开发成为可能。此“框架”可以是独立的工具，也可以是某个现存 IDE 的插件或者更新。

宽泛地说，有两种用于框架的通常方法以在程序分析工具之间传递信息。第一种方法将某个检查器作为插件整合进现存的编译器工具链中。现代编译器框架，例如 gcc、Clang 和 Frama-C，使得编写新的插件变得简单。更进一步地，插件通常被允许更新某种 AST 或者中间形式，由此允许插件使得它们的分析结果对于其他插件可用。例如，Frama-C 编译器框架提供了一个插件库，它包含 use-def 和指针别名分析，这些对于编写语义分析器通常是必需的。第二种方式依赖于某种通过写入到硬盘或者通过网络发送以传递信息的通用格式。此方法的一个范例是证据性工具总线 \[Rushby05\]，它允许由不同厂商制造的多个分析引擎交换逻辑结论以执行高级程序分析。信息应该被附加到代码以使其成为“随码担保”\[Woody16\]。某种附加框架将会同时支持两种信息传输方式以便尽可能多地重复利用现有成果。

本节中所引用的框架能力专注于在工具之间交换信息，而非 2.4 节讨论的框架的开发能力。

### 2.3.3 分析结果合并策略

有了适当的标准和框架，我们就能够获得通过累加或者合并不同的软件分析结果所带来的额外的好处。软件分析结果可以通过 3 种通常的方式累加起来。第一种情况简单地说就是获取更多信息。假设程序员已经拥有某种工具以检查注入 bug（INJ 类）\[Bojanova16\]，添加一种工具以检查死锁可以为程序员提供更多信息。

第二种情况是确定性或者矛盾性。程序员可能拥有两种不同的启发式搜索以查找错误操作（FOP 类）bug \[Bojanova16\]，它们各自拥有独立的几率以报告真实的 FOP bug 和假阳性。此架构可以用于对两种启发式搜索的输出进行相关以得到具有较少假阳性的单一结果。与之相反，一种工具可能会宣称某个语句可到达，而另一种工具则宣称并非如此。这种矛盾性可能指示二者的假设存在差别，或者某个工具中存在错误。某种工具使用的一系列演绎规则孤立地看可能具有一致性，但是与来自另一种工具的规则并不具有一致性。

附加软件分析的第三种情况是协同作用。某个在关于内存使用和数据结构的形式化推理方面具有特长的研究小组可以在由某个专长于对二进制代码进行“语法分析”的小组开发的组件的基础之上进行开发，由此创建一种能够对二进制文件的内存使用进行推理的工具。开发者可以更加快速地对混合和符号测试担保工具进行试验。例如，某个工具可能会使用静态分析器以获得可能存在的问题的代码的位置，然后利用约束满足问题求解器和符号执行来创建能够在每一个位置触发错误的输入。

### 2.3.4 分析结果合并技术

一旦经过训练，这样的神经网络自身可以作为漏洞检测引擎。来自手动分析的不正确结论是时间和资源密集的。为了保证高效，上述结果合并策略必须利用适当的技术在工具中实例化。例如，Code Dx \[CodeDx15\] 是一种用于匹配、合并并且呈现分析工具的输出的工具。更加强大的方法是应用机器学习技术，诸如微软的认知服务和计算网络工具包，以及 Google 的 TensorFlow 等。

执行深度学习和神经网络的训练和推理阶段所必需的底层硬件的价格已经显著下降。云服务现在可以按需提供高端图形处理器（GPU）实例。这样的计算能力显著增强了机器学习算法的速度，允许利用显著增大的数据集合对其进行训练，以及实现显著加快的训练和反馈循环。那些已经搜集了大量关于漏洞、漏洞利用、恶意软件、rootkit 以及后门信息的素材的组织机构可以利用众所周知的数据科学技术挖掘这些信息以推导出新的洞察力和价值。

一旦经过训练，这样的神经网络自身可以作为漏洞检测引擎。来自人类实践者的不正确结论可以被反馈回训练阶段以自动加强算法或者网络的辨别力，并且渐进式地改进它们。这些技术拥有在宽泛的语言集合中检测漏洞的潜力，包括那些新开发出来的，尚无良好建立的分析工具的语言，并且甚至可以检测出新的漏洞类别。

这种检测能力可以增强现存的工具链。更重要地，来自其他分析工具的结果可以成为这些强大技术的训练和分析的额外的信息来源。这些同样的网络，只要得到足够的资源，在实现识别并且优先解决具有风险的组件这一相同目标的同时还能够分析大片源代码。

### 2.3.5 成熟度水平

大多数常用的编译器，诸如 gcc、Clang 和 Frama-C，提供了添加用于处理和更新 AST 和 IR 表示的插件的内建支持。此外，大型社区已经开发出了广泛的库和插件，并且创建了带有入门教程和参考手册的百科网站以降低新用户参与其中的门槛。对于语义表示的情况，社区规模较小并且入门门槛较高，尽管诸如 Boogie 等语言已经被若干研究小组成功地用作引擎以构建用于多种语言的检查器，诸如 C \[VCC13\] 和 Eiffel \[Tschannen11\]，甚至还可用于操作系统 \[Yang10\]。

有众多当前的软件信息交换系统，诸如 LLVM、ROSE、gcc 的 GENERIC 或者 GIMPLE，以及知识发现元模型（KDM）等。用于合并工具的输出的格式，诸如工具输出整合框架（TOIF）和软件担保发现表达纲要（SAFES）\[Barnum12\]，已经暗示了关于软件的有用知识类别。

### 2.3.6 可信度的基础

当今领先的静态分析工具具有低假阳性率，这已经引起了其在业界和政府组织之间的更多采用。而这反过来又激励了编译器团队以增加对于那些能够对内部程序表示进行操作的插件的支持。有一些大型并且活跃的用户社区正在为接口编写文档，以及为那些能够被合并起来以构建复杂分析器的插件创建库。确实，挑战并不在于某种附加软件分析方式能否工作，而是在于投资哪一个，以及如何将它们捆绑起来。

### 2.3.7 潜在影响的基本原理

早期的静态分析工具检查的主要是程序的语法属性，强制执行编码指导原则并且查找对应于简单运行时错误的结构，诸如对空指针解除引用，或者在赋值之前使用变量。随着分析器变得更加高级，它们越来越依赖于对于程序结构和数据流的更加复杂的分析。允许用户构建能够共享和合并结果的小型分析引擎的常用框架将会使得构建高级分析器成为可能。这样的分析器可以发现隐晦的错误，而这样的错误难于利用传统的测试和模拟技术来发现。

这样的框架和标准应该允许模块化和分布式的开发，并且允许现存模块被替换为更好的。它们还应该有助于不同小组的研究人员之间的协同作用。它们应该加速工具的“生态系统”的成长以及下一代“混合”工具的开发。混合工具可以使用静态分析模块来查找有问题的代码的位置，然后使用约束满足条件求解器模块和符号执行引擎来创建能够触发错误的输入。不断增长的、共享的一系列有问题的和良好的编程结构和习惯用法可以最终由工具进行检查 \[Kastrinis13\]。

### 2.3.8 延伸阅读

* \[Bojanova16\] Irena Bojanova, Paul E. Black, Yaacov Yesha and Yan Wu, “The Bugs Framework (BF): A Structured Approach to Express Bugs,” 2016 IEEE International Conference on Software Quality, Reliability, and Security (QRS 2016), Vienna, Austria, 1-3 August 2016, [https://doi.org/10.1109/QRS.2016.29](https://doi.org/10.1109/QRS.2016.29).
* \[Kastrinis13\] George Kastrinis and Yannis Smaragdakis, “Hybrid Context-Sensitivity for Points-To Analysis,” _Proc. 34th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '13)_, 2013, pp. 423-434, [https://doi.org/2499370.2462191](https://doi.org/2499370.2462191).
* \[Rushby05\] John Rushby, “An Evidential Tool Bus,” in _Proc. 7th international conference on Formal Methods and Software Engineering (ICFEM'05)_, Springer, 2005, p. 36, [https://doi.org/10.1007/11576280_3](https://doi.org/10.1007/11576280_3).

## 2.4 更多成熟的领域特定软件开发框架

简单地说，此方法地目标是提升经过良好测试和良好分析的代码的使用（和重复使用），并且因此减少可被利用的漏洞的发生几率。

如同在 4.3.6 节叙述的那样，将可重复使用的软件组件组织进组件库或者版本库的理念至迟可以追溯到 1968 年 \[McIlroy68\]。为了使得软件可以重复使用，可共享的软件组件可以被打包进一系列构建块中，例如独立程序、服务、微服务、模块、插件、函数库、框架、语言（如 2.1.4 节注释）、类，以及宏定义等。一套这样的（传统）构建块通常构成了新的软件开发努力的起点。或者更加通俗地说：几乎没有任何东西是从头创建的。因此，新的软件系统的漏洞决定性地依赖于最恰当的现存组件的选择和应用，以及新代码与传统组件之间的相互作用。

尽管代码共享的单元可能很小，例如单个函数或者宏，使用成熟、高价值的组件可以带来实质性的好处，在此，代码清洁性、领域知识和代码质量方面已经进行了大量投资。

软件框架包含代码，以及更重要地，它还定义了利用它所构建的程序的软件架构（包括默认行为和控制流）。领域特定的框架还包括领域知识，例如 GUI 构建、语法分析、网络应用程序、多媒体和计划等。成熟的领域特定框架一旦被软件开发者学习，可以使得程序的快速生产成为可能，这些程序从软件视角以及领域知识视角来看都是经过良好测试的。在最佳案例场景中，在此，成熟的框架被专家恰当地使用，有实质性的机会以避免那些可能导致可被利用的漏洞的软件错误。

然而不幸的是，这种最佳案例场景难于实现。具体地说，为了实现成熟框架所带来的好处，软件开发者必须克服若干种重大挑战。

**查找适合的框架**：存在着太多的框架。例如，在 2016 年九月对 github.com 进行简单的搜索，即显示了超过 171000 个版本库，在其名称或者描述字符串种包含单词“framework”（框架）。（尽管这些架构中有一些反映出了其在设计清洁性和质量方面的巨大投资，其它的则是被仓促构建的、具有不可知的来源，或者可能是恶意的。）这些框架通过范围宽泛的编程语言（PHP、JavaScript、Java、Python、C# 和 C++ 等）实现，并且众多框架使用多种编程语言。额外的复杂度来源于包管理器和构建系统的多样性，这种多样性必须被潜在的框架客户端学习。软件开发团队面临巨大挑战，而只是为了调查可能支持某个项目的要求的可能的框架；这种挑战是足够急迫的，以至于有一个项目 \[TodoMVC16\] 的存在完全是为了帮助开发者在可用的（模型视图）框架中作出选择，通过出于比较的目的显示一个由多种框架实现的示例应用程序。在受到调查的框架中评估其适用性是一种更进一步的挑战。众多框架在其构建进程中包括某种形式的测试，通常是单元测试 \[Beck94\]。这样的现存测试需要被评估其相对于某个项目的目标的充分性。一个更进一步的问题是，不同的平台提供不同的安全特性（例如访问控制列表、签名的可执行文件以及白名单等）。对于框架对某种特定平台的要求程度，选择该框架时必须考虑对于平台特定的担保特性的理解和使用。

**学习新框架**：Brooks 说过，软件包括了“基本”和“偶然”的信息 \[Brooks95\]。基本信息是关于算法和软件所必须执行的基本操作的。偶然信息是关于接口细节、编程语言的选择、在系统中为元素取的名称等等的。每一种框架都包含这两种信息，这必须在专家水平被理解，以使得框架被安全地应用于非平凡的应用程序。尽管专家可能已经知道关于某个问题领域的大部分基本信息，偶然信息不能被预期。

对于一种通用数据结构，列表的快速精读展示了这种基本的困难。列表的涵义被大部分软件开发者所熟知，但是实际创建并且使用列表数据结构所必需的信息在相互竞争的环境之间大不相同。例如 Unix 的 queue.h 宏、Java 集合、JavaScript 数组、Python 的内建列表，以及 C++ 标准模板库中的列表模板等，它们都实现了相同的基本理念，但是使用大不相同的细节。一位软件开发者对于列表的概念以及某些列表实现可能是专家，但是对于在新框架中的具体的列表实现的使用而言则可能完全是个初学者。因此，这位开发者必须花费时间以低效地学习（通常是大量的）偶然信息。如果开发者受困于计划压力而最小化这项预备工作，基于框架的初学者级别的软件可能被制造出来，它更有可能包含瑕疵和漏洞。

**理解并且控制依赖**：一种框架可能依赖于其他框架，由此得到的依赖传递图可能是庞大的。框架用户可能会在其依赖于可能是庞杂的框架代码的项目中轻易发现漏洞，这些代码被自动包括进来，或者通过传统的包管理器和构建系统间接包括进来。2016 年的“leftpad”事故展示了这种危险性。被重度使用的 Node 包管理器维护着不计其数的包，它们可以被 JavaScript 程序轻易地引用和使用。当一起所有权争论于 2016 年爆发时，一位开源作者从 Node 包管理器中反发布了他的超过 250 个模块。其中之一就是微小的函数“leftpad”，它向字符串中添加填充的空格或者零。数以千计的程序，有些是非常重要的，依赖于“leftpad”并且突然不能工作，直到被反发布的包再次被“反反发布”\[Williams16\]。

**解决框架组成的不兼容性**：多种框架可能不能同时应用于同一程序中，或者即使它们可以，其包含顺序或者版本可能很重要，由此导致脆弱的代码。在其他案例中，诸如 lex/yacc 代码生成工具，显式的操作是必需的，以避免名称空间冲突，进而允许框架的多个实例共存于一个程序中。这样的冲突可能是隐晦的，如同 Lampson 所指出的，每一个组件可能拥有不同的“世界观”，而 _n_ 个组件的组合可能得出 _n_<sup>2</sup> 种相互作用 \[Lampson04\]。

这些是长期存在的挑战。更进一步地，由于当前可用于开源的框架（具有不同的来源和质量）的巨大并且仍在增长的数量，这些框架通过由诸如 GitHub、JIRA、Bitbucket、CollabNet 等版本库管理实体托管的公开版本库而可用，选择一种适合的框架的困难可能会更加急迫。然而，这种广泛的使用同样表现出了重要的机会：如果在框架如何被发现、学习、进行依赖管理和编写等方面可以取得哪怕是微小的改进，很多软件漏洞就可以被避免。

另一个显著的进展是，通过利用诸如 stackoverflow 或者 stackexchange 等软件问答网站进行复制/粘贴操作的软件开发方式（包括框架使用）成为主流。尽管基于问答的代码重复利用可能是快捷的，它也可能导致理解不良和整合不良的解决方案。获得关于提出的问题的答案和示例代码的能力可以明显地有助于开发者的理解，然而，需要技术以便在采用他人的解决方案时避免产生漏洞。

尽管这些是巨大的挑战，当前的最先进技术提供了机会以撬动现存的代码以及技能资源，同时利用新的技术和工具以增强它们。

### 2.4.1 快速框架采用

框架的采用很明显地受到了需要学习大量偶然信息这一点地阻碍。Gabriel 将“宜居性”定义为“使得程序员、编写代码者、修复 bug 者和人们在代码的生命后期来到该代码时能够理解其构造和意图并且舒适地以及满怀信心地更改它的源代码特征”\[Gabriel96\]。由于意识到了实现宜居性的挑战，Gabriel 提议使用软件结构以帮助开发者快速理解现存代码，并且标记出负面实践的使用。尽管不是一种万灵药，结构（例如 \[Gamma95\]）可以有助于将框架提供者和框架消费者之间的鸿沟桥接起来。有助于实现这一点的一种方式是开发一系列涵盖了流行领域的结构。2016 年九月关于 GitHub 上的前 10 名最流行（“星级”）和最多“分叉”的版本库的非正式调查显示了围绕这些方面的显著框架活动：网络应用程序开发、前端网络开发、操作系统内核、跨平台应用程序框架、虚拟机管理、编程语言和异步 http 服务器。加速其采用的一种方式是制定关于这些领域中的某些的软件结构，其焦点是协调不同框架之间的偶然信息（于是它无需被学习很多次），并且制造关于通常应用案例的文档。随后可以进行实验以测定其有效性，通过比较有和没有新的结构信息时的架构使用情况。

### 2.4.2 高级测试方法

除了民航（在此领域，软件被根据极其严格的美国联邦航空管理局（FAA）标准而构建和测试）的特例以外，商业软件通常只会得到最小化测试。那些将上市时间作为其至高无上的目标的行业尤其如此。测试可能被局限于只有关于必要的功能已被实现这一点的基本担保，有时被称为“快乐路径”，或者积极测试，它们展示了功能，但是并不提供关于不良行为并不存在这一点的担保。

高级测试方法坚守显著增加框架强壮度的承诺，并且更进一步地，构建关于在与依赖相关的不同假设之下的框架组成的担保。众多框架当前只采用临时安排的测试。其他一些框架则采用标准单元测试 \[Beck94\]，并且实践于不同的完整性级别。自动化的测试，诸如 QuickCheck \[Claessen02\] 或者不同的模糊工具可用于大多数语言。关于传统测试套件的覆盖度测定的最近进展提供了机会以比较框架。组合测试将大量输入值的组合压缩为少数测试 \[Kuhn10\]。框架可以被自定义或者配置的众多方式提示了一种在软件框架应用中获得新的可信度的可能方式。通过展示高质量的组合，这样的测试拥有潜力以强调框架的相似性，降低学习曲线并且允许经过良好测试和良好分析的代码的更宽泛的采用。

### 2.4.3 多框架组成中的冲突解决

在某些案例中，多种框架可能被并行使用而不会产生冲突。在其他案例中，允许并行使用的组成可能是脆弱的。居于主导的框架结构，诸如控制反转（IoC）\[Busoli07\]——又称为好莱坞原则：“不要调用我们，我们将会调用您，”可能会加剧这种情况，由于每一个框架可能会假设是由它在整个应用程序中定义控制流。一种化解方式是虚拟化框架操作，利用例如轻量级操作系统容器 \[LXC\] 并且随后在并行执行的框架之间建立通讯链接。另一种冲突解决的方式是使用软件翻译来重写框架，以使得它们的重叠元素各不相同。先期努力可以展示这些以及其他解决冲突的策略的可行性，并且比较它们的成本以及对于应用程序漏洞的影响。

### 2.4.4 成熟度水平

关于软件结构的文献极其广泛，并且软件测试是计算机科学中的一个相对成熟的子领域，至今已经被实践了 40 多年。框架本身现在是软件共享中的主导单元。上述 3 种技术：结构、测试和框架，正在持续的使用和详细化进程中。

### 2.4.5 可信度的基础

毫无疑问，可以为若干种主要框架的结构编写文档；快速的采用可能更多地是渐进式的进展而非革命性的进展，但是，渐进式的进展应该从投资流向结构文档。将会受到框架组成的影响的高级测试技术是相对成熟的，这增加了关于框架整合可以被有效测试的可信度。

### 2.4.6 潜在影响的基本原理

代码重复利用是无处不在的，并且看起来正在加速；通过对非常流行的框架进行投资，任何进展都会变得广泛相关。

### 2.4.7 延伸阅读

* \[Software16\] “Software framework." Available: [https://en.wikipedia.org/wiki/Software_framework](https://en.wikipedia.org/wiki/Software_framework) Accessed 13 October 2016.
* \[TodoMVC16\] “TodoMVC: Helping you select an MV* framework." Available: [http://todomvc.com/](http://todomvc.com/) Accessed 13 October 2016.
* \[Wayner15\] Peter Wayner, “7 reasons why frameworks are the new programming languages," 30 March 2015. Available: [http://www.infoworld.com/article/2902242/application-development/7-reasons-why-frameworks-are-the-new-programming-languages.html](http://www.infoworld.com/article/2902242/application-development/7-reasons-why-frameworks-are-the-new-programming-languages.html) Accessed 13 October 2016.

## 2.5 移动目标防御（MTD）和自动软件多样性

此方法是一系列技术的集合，以自动改变软件的细节结构和属性，使得攻击者在利用任何弱点时的困难大大增加。为了说明，考虑此家族中最近被提议的技术之一：堆内存随机化 \[Iyer10\]。当程序请求一块缓冲时，最简单的方式就是返回下一段可用的内存中的一块。这将缓冲置于相同的相对位置。如果知道了这一点，攻击者可以利用一块缓冲中的缓冲区溢出弱点（即 BOF 类）\[Bojanova16\] 以便，例如，读取总是位于该缓冲之前 384 字节处的另一块缓冲中的口令。堆内存随机化将会在每一次分配过程中分配随机数量的额外内存。这将缓冲置于不同（不可预测）的相对位置，于是上述漏洞利用的难度大大增加，或许根本不可能。

软件多样性和移动目标防御（MTD）的目标是降低攻击者利用软件中的漏洞的能力，而非减少软件中的弱点数量。这种降低可以通过改变“攻击面”而实现，攻击面即可供攻击者访问的跨越时间（在操作过程中发生更改）或者跨越副本（多样性）的接口。这种降低可能还包括再生受到攻击的系统组件 \[Knight12\]。

当然，多样化必须是安全的。即发生的更改对于正常行为没有影响，而非可能增加资源使用。即使加上这一条约束，我们仍然可以牺牲计算能力以换取多样化中增加的粒度或者完全程度。增加的粒度被预想为能够针对未知漏洞利用提供更好的保护，由于具有较高的几率以影响对于攻击至关重要的某些信息片断的位置或者值。这种折衷类似于静态分析，参见 2.1.1 和 2.1.2 节：投入的资源越多，担保的量就越大。区别在于，静态分析找到特定漏洞以使得它们可以被修复，而导致多样化的变换增加了利用整类漏洞的难度。

### 2.5.1 编译时技术

编译时技术时那些由编译器自动应用的技术。它们可能引起每一次编译得到相同的可执行文件，以使得可执行文件随后在运行时选择随机的行为或者内存布局，或者它们也可能引起每一次编译得到不同的可执行文件。

一些特定技术包括数据结构布局随机化、函数调用中的不同的参数顺序、地址空间布局随机化（ASLR）\[PaX01\]、指令集随机化、数据值随机化、应用程序关键字标记，以及具有操作混淆和重构的可变指令顺序。

对于证明这些多样化是安全的这一点有用的程序信息对于旨在发现或者移除漏洞的程序分析同样有用。附加软件分析方法，如 2.3 节所详细叙述，是为了使用相同的计算能力以同时检测或者移除弱点，并且也会随机化剩余的弱点。这些多样化技术可以通过附加分析框架以捆绑进静态分析工具，从而潜在地只需要极少的资源开销。

然而不幸的是，当今没有工具做到这一点。分析软件通常由程序员在开发时运行。多样化通常只会在系统测试阶段或者操作阶段当其显示了弹性的时候展示出它的好处。往坏里说，多样化为测试结果增加了歧义性，并且使得追踪造成故障的根源变得更难。为了反制这种努力和好处之间的脱节，使用了多样化的程序应该被特别致谢，以使得消费者知道它们使用了一个额外层级的弹性。那些产生了极度多样化的结果的编译器同样将会减少对手通过检查某个程序的最新和先前版本之间的差异来发现漏洞的几率：它们将会过于不同 \[Franz10\]。

### 2.5.2 系统或者网络技术

某些位于系统或者网络层级的技术包括网络地址空间随机化和协议多样性 \[Rowe12\]。它们可能在其根据规则基础发生变化时成为动态的。在众多案例中，这些技术是基于对于从服务到地址的共享秘密地图或者共享秘密密钥的假设而构建的，以使得应用程序可以认证并且获得当前信息。

### 2.5.3 操作系统接口技术

操作系统（OS）可以对不同的进程呈现不同的接口。这些接口可能是动态的，诸如为每一个系统服务指认的随机中断号，也可能是静态的，其中 OS 对于每一组服务拥有若干种选择。在动态情况下，链接器/加载器可以将每一个新的可执行文件调整至为该进程作出的指认处。作为静态情况的一个范例，OS 为新的进程呈现了一组 _j_ 种内存管理 API、一组 _k_ 种进程服务、一组 _m_ 种网络函数，以及一组 _n_ 种 I/O 调用。试图执行通过该进程的入侵代码将会不得不应对 _j_×_k_×_m_×_n_ 种不同的 OS 接口以获得成功。

### 2.5.4 成熟度水平

一些移动目标防御是当今众多操作系统和编译器的默认值。有大量研究和整场会议专注于理解当前技术的局限、成本和好处，并且开发新的、更好的技术。

### 2.5.5 可信度的基础

就挫败的攻击数量、吓退的攻击者，或者攻击者所必需的额外资源而言，这些好处是未知的。然而，众多 MTD 技术可以被自动应用，例如由编译器来应用，几乎不用付出资源或者运行时间的代价。

### 2.5.6 潜在影响的基本原理

MTD 技术可以被应用于当今的大多数程序和系统，甚至是静态嵌入式系统。因此，其好处的范围是非常大的。其影响并不明确，由于大多数技术增加攻击者的成本，而非严格意义上地消除漏洞。

### 2.5.7 延伸阅读

* \[Okhravi13\] H. Okhravi, M. A. Rabe, T. J. Mayberry, W. G. Leonard, T. R. Hobson, D. Bigelow and W. W. Streilein, “Survey of Cyber Moving Targets,” Massachusetts Institute of Technology Lincoln Laboratory. Technical Report 1166, 25 September 2013. Available: [https://www.ll.mit.edu/mission/cybersec/publications/publication-files/full_papers/2013_09_23_OkhraviH_TR_FP.pdf](https://www.ll.mit.edu/mission/cybersec/publications/publication-files/full_papers/2013_09_23_OkhraviH_TR_FP.pdf) Accessed 13 October 2016.

