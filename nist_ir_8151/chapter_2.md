# 第 2 章 技术方法

有众多具有不同成熟度等级的方法展现出了对于减少软件漏洞数量的巨大潜力。此报告突出强调了其中 5 种足够成熟并且被证明为成功的方法，因此有可能将其外推到 3～7 年的视界中来。此列表的本意并非穷尽性，而是为了展示在减少漏洞方面取得显著进展是可能的，并且为了取得这一充满雄心壮志的目标铺平道路。SPSQ 研讨会的重要主题之一是这样一种需求，即不仅仅要改进软件，还要通过应用形式化技术来改进测试工具。

## 2.1 形式化方法

形式化方法包括基于数学和逻辑的所有软件分析方法，包括语法检查、类型检查、正确性证明、基于模型的开发，以及自动建构校正等。形式化方法可以帮助软件开发者取得关于整个类别的漏洞都不存在的更大的担保，并且还可能有助于减少不可预测的昂贵的测试和 bug 修复周期。

在编程的早期，某些实践者证明了他们的程序的正确性，即给定语言语义，他们从逻辑上证明了他们的程序具有某些属性或者能够得到某些结果。随着软件的应用爆炸式增长，以及程序变得如此之大，以至于单纯的手动证明变得不可行。形式化正确性参数不再流行。近几十年的发展，诸如由摩尔定律预测到的处理能力的激动人心的增长、多核处理器以及云计算，使得随时可用的计算性能增加了好几个数量级。用于求解布尔可满足性（SAT）问题、可满足性模数理论（SMT）\[Bjørner16\]、决策过程（例如有序二元决策图——OBDD）以及推理模型（例如抽象的解读和分离逻辑）等问题的算法的进展极大地削减了回答这些关于软件的问题所必需的资源。

关于使用形式化方法以实现大幅减少漏洞的早期努力之一是 20 世纪 80 年代美国国防部的可信计算机安全性评估判据（TCSEC）。TCSEC 详细叙述了多个层级的软件担保。其最高层级 A1 要求对于系统的形式化说明以及对于代码和说明之间的相关性的数学证明。成功的定理证明工具被开发出来，并且若干种经过形式化证明的系统被制造出来，但是实际使用所必需的代价和时间令人难以接受——多达 2 年。

到了 20 世纪 90 年代，形式化方法得到了这样的名声，即消耗太长太长的时间，不论是机时、人年还是项目时间，并且需要计算机科学的博士学位，还要懂得数学才能利用它们。现在的情况已经不尽如此。今天，形式化方法被普遍使用。例如，编译器利用 SAT 求解器以分配寄存器并且优化代码。操作系统利用形式化保证的算法以避免死锁。Kiniry 和 Zimmerman 称这些为“隐秘忍者式的形式化方法”\[Kiniry08\]：它们对于用户不可见，除非是报告某些东西不正确。与这些“不可见”的形式化方法的使用相反的是，显式的使用通常要求将问题重新呈现为某种与形式化方法工具兼容的形式。

显式形式化方法在机动车 \[ISO26262-6\] 和铁路 \[Boulanger15\] 标准中被推荐。形式化证明技术显著减少了取得由空运标准 DO 178B 所定义的目标所需付出的努力 \[Randimbivololona99\]。其继任者 DO 178C 拥有一整套补充：DO 333，它专门针对将形式化方法用于软件验证。大多数被提议的密码学协议现在经过模型检查器检查以查找可能被利用的漏洞，并且分析者可以执行实现了密码学算法匹配规范的几乎完全自动化证明 \[Carter13\]。实践者们还利用模型检查器以查找网络中的攻击路径。

抛开它们的长处，如果对于软件要求没有明确的声明，或者到底是哪些东西构成了恰当的软件行为这一点只能通过人类判断或者平衡众多相互冲突的因素来确定，则形式化方法不那么有效。因此，我们将不会期待形式化方法对于评估用户界面的可用性、部署探索性的软件，或者非结构化的问题作出那么大的贡献。

形式化方法包括软件开发的所有阶段以及众多不同应用领域的众多技术，我们不能列出每一种潜在地有帮助的形式化方法。与之相反，我们专注于可能在中期作出显著贡献的少数方法。

### 2.1.1 可靠的静态程序分析

静态分析是在不执行软件的情况下对其特定属性进行检查的过程。出于我们的目的，我们只考虑自动化的分析。启发式分析比可靠性分析更快，但是缺少来自于逻辑推理链的担保。有些问题只能通过在分析的条件下运行软件，即通过动态分析来回答。结合静态和动态分析将会得到一种混合技术。特别地，通过执行软件可以得到关于那些不能仅仅利用静态技术来确认的属性的存在性证明。

软件的众多呈现形式（例如系统要求、架构、源代码和可执行文件）可以进行静态分析。然而，源代码分析是最成熟的。源代码分析的优势之一在于，在源代码中识别出来的问题的上下文可以通过熟悉的呈现形式传递给软件开发者：代码本身。如果其他呈现形式被分析，则需要额外的步骤以将报警信息转化为某种形式，人们可以首先理解它，并且随后将其与分析中的程序相关联。

根据 Doyle 的评估，可靠的静态分析在覆盖度、可缩放性和付出努力的回报等方面均优于当前的软件开发实践 \[Doyle16\]。我们相信其限制之一是某些属性难于通过可用的概念来叙述。

形式化描述和可靠的静态分析在近年来已经展示出显著的适用性。例如，Tokeneer 项目展示了利用形式化方法开发软件比传统软件开发技术更快、更廉价，并且具有更少的 bug \[Barnes06, Woodcock10\]。TrustInSoft 利用 Farma-C 以证明 PolarSSL 中不存在一系列通用缺陷列表（CWE）中的类，它现在称为 mbed TLS \[Bakker14, Regehr15\]。Ourghanlian 比较了 PolySpace 验证器、Farma-C 和 Astrée 的应用以评估核电站中的安全关键软件 \[Ourghanlian14\]。可靠的静态分析和其他形式化方法被广泛应用于不限于交通运输、航空航天、核电站控制等领域的软件开发 \[Voas16b\]。

这些进展体现出了静态分析的众多应用中的少数。更进一步，静态分析拥有这样的潜力以有效地排除新开发的软件中的若干类错误，并且减少与通过测试达到更高层级的担保所需资源相关的不确定度。

### 2.1.2 模型检查器、SAT 求解器和其他“轻量级”决策算法

这些算法可以解答关于理想的更高层级属性的问题，诸如某个协议仅在某人拥有某个密钥的情况下允许读取敏感文本、安全属性由系统预留、某项赋值满足多个限制条件，或是没有途径通过（已知的）攻击进行突破。这些算法也可以被应用于分析具体的设计产物，诸如有限（以及无限）状态机。

Doyle 的评估结论是，模型检查器可能拥有优异的覆盖度，很多属性可以被呈现 \[Doyle16\]。然而，由于所需的努力随着问题大小呈指数增加，总会有某个事实上的大小限制。小于该限制的问题可以被快速求解。非常大型的问题可能要求额外的资源或者密集的人力以便将此问题分解为合理的部分。

这样的技术实质上可以通过两种方式应用。其一，它们可以被用作生产中的软件的一部分。例如，与其使用某种临时安排的程式以便为一台运输卡车查找一条高效的路径，某个应用程序不如使用已有深入研究的旅行推销员或者生成树算法。其二，可能也是与此报告的主题更加相关的方式是使用这些方法来设计或者验证软件。

### 2.1.3 断言、先决条件、后置条件、不变量、切面和契约

程序员通常拥有一个信息体以为其提供关于软件将会按照预期执行的信心。形式化方法中的一个被忽略的部分是无歧义地记录这些洞察力。变量拥有不同的术语，诸如契约、断言、先决条件、注释、后置条件和不变量等。这可能会使得程序员花费额外的思考以使用某种类似于代码表达式的语言来精确地叙述将会发生什么，但是这样地声明是会带来帮助的。诸如由反例指导的抽象详细化（CEGAR）等自动化辅助工具可以帮助生成声明。这些声明在开发和测试过程中被激活（“编译进来”），然后可以在发布之前取消激活。

这种方式的好处是，关于代码中具有的属性的形式化声明可以被用于对代码进行交叉检查。例如，测试可以通过断言直接生成。它们可以被激活以便在测试或者生产过程中执行内部一致性检查。由此可以使得错误被检测出来的时间大大提前，并且距离出错的代码更近，而非不得不从外部可见的系统故障进行回溯。基于断言的测试可以检测出具有适当的覆盖度水平的输入空间中的多达 90% 的错误 \[duBousquet04\]。这样的声明还提供了额外的信息以执行关于程序正确性的半自动的证明。与在代码更改时不会被更新的注释不同的是，这些声明可以被计算机证实或者强制实施，并且因此必须持续成为关于程序特性和属性的准确声明。

关于这样的形式化声明可以如何带来帮助的一个令人印象深刻的例子是 1996 年的阿丽亚娜-5 运载火箭首次发射失败。阿丽亚娜-5 使用了来自取得成功的阿丽亚娜-4 的软件。当阿丽亚娜-4 被设计之时，分析显示 16 位整数能够处理其速度。然而，阿丽亚娜-5 的更高的速度使得该变量溢出，导致计算机关机以及运载火箭失事。如果其代码拥有关于其速度必须能够适配进 16 位整数的先决条件，“任何称职的团队将会检查……\[此先决条件，它\] 将会立即提示阿丽亚娜-5 的调用软件并不满足它所调用的阿丽亚娜-4 例程的预期” \[Jézéquel97\]。

### 2.1.4 自动建构校正和基于模型的开发

在基于模型的开发中，软件开发者创建并且修改系统的模型。其行为可以在某种更高级或者领域特定的语言或者模型中说明，随后其代码被自动生成。大部分或者全部代码是从模型生成的。这是一种自动建构校正技术。此技术和诸如详细化设计等其他技术致力于完全避免整类漏洞，由于开发者极少接触代码。与此类似的代码合成相对于其他形式化方法适用于较少的情况，由于这对于为某些领域开发建模超结构和代码生成器是不可行的，例如，某种具有错误恢复和帮助提示的用户界面。这样的模型或者规范还可以生成测试套件或者准则。它们还可以被用于验证或者监视系统运行。

如果分析者能够指定整个系统，或者哪怕只是子系统的完整的高层级模型，我们就称此模型为“领域特定语言”（DSL），并且不再认为它值得一提。这代表了形式化方法的一种实质性的应用。根据 Doyle 的评估，程序合成在覆盖度方面等级为“A+”，而在努力和属性方面等级为“B”\[Doyle16\]。

### 2.1.5 经过验证的工具和代码目录

软件开发者通常必须花费大量努力以便将具有已证明的属性的工具或者开发程序认定为合格。即使如果后期的开发者想要使用这样的工作成果，也没有中央结算机构可供咨询。关于经过验证的工具、精心构建的库，甚至是可重复使用的规范和要求都能够加速形式化方法的采用。这样的工具库可能有助于具有显著减少的漏洞数量的软件的更宽泛使用，并且具有随之而来的担保。

众多企业和政府机构评估用于类似用途的相同的工具或者软件。由于可能难以发现谁已经完成了相关评估，每一家实体都必须重复此工作，有时它们的知识和细致程度还不如其他实体已经投入的。这特别具有挑战性，由于众多合同条款阻碍分享成果 \[Klass16\]。一份库或者列表将会带来巨大利好。一旦得知相关的努力成果，开发者可以为一项努力成果作出贡献，而非从事他们自己的努力。作为某个库的代码或者“即时”实例化成果，开放式网络应用程序安全计划（OWASP）基金会协调组织了一个项目以开发一个囊括了关键安全性操作的应用程序接口（API），它称为企业安全性 API（ESAPI）。

参见 2.4 节以获得关于经过良好测试和良好分析的代码的重复利用的讨论。

### 2.1.6 网络加固：使形式化方法发挥作用

上述技术可以被用于开发软件，然而，重制所有遗产软件是不可行的。这被称为“网络加固”，以同旨在获得对于地震的更高抵抗力的“抗震加固”相类比 \[Fisher16\]。第一步是识别现存系统中最具决定性、关键性或是基础性的组件。SPSQ 研讨会参与者还强调了将形式化方法用于关键模块而非整个应用程序。除了基于目的编写的代码以外，关键组件还可以是编译器或者运行时库。这些组件随后利用适当的形式化方法仔细检查或者重建以获得更高层级的担保，如同在 PolarSSL 中所进行的，它现在称为 mbed TLS \[Bakker14, Regehr15\]，继 Heartbleed 或者 CompCert 验证 C 编译器之后 \[Leroy06\]。

网络加固中的另一个小步骤是在具有自动强化或者加固的情况下重新编译组件。例如，编译器可以在每当可能时对所有的内存访问添加边界检查，以极大地减少未被识别的缓冲区溢出（BOF 类）的数量 \[Bojanova16\]。这样的强化几乎没有任何性能影响 \[Flater15\]。编译器还可以利用更为安全的“加强”函数来替换典型的不安全函数，并且可以利用可执行空间保护，例如将用于数据的内存区域标记为不可执行。

### 2.1.7 成熟度水平

今天，形式化方法在全世界被使用，通常是相对地隐秘的。最为普遍的应用之一是现代编程语言中的强类型检查，这是一种形式化方法。其他尽管有限的应用包括不同软件检查工具的算法，它们中的某些被构建到广泛使用的开发环境中（例如标记出对变量的不一致使用、缺失的值或者不安全接口的使用）。在 2010 年，澳大利亚国家信息通讯科技卓越研究中心（NICTA）的研究人员展示了对于包含约 10000 行 C 代码的 seL4 微内核的形式化验证 \[Klein14\]。英国国家航空交通服务控股公司（NATS）的临时未来领域控制工具支持（iFACTS）包含超过 200000 行 SPARK 代码，并且“所有代码更改 _必须_ 被证实为良好，然后代码才能被提交”\[Chapman14\]。

### 2.1.8 可信度的基础

断言、契约、不变量以及其他形式化声明在高质量软件中已经得到大量采用。它们之所以得到逐渐改进以涵盖更多高级条件和 API 检查，是由于它们已经在开发者社区中证明了自己的价值。例如，源代码注释语言（SAL 2.0）在微软 Visual Studio 2015 中可用。众多工具现在可以执行静态分析。一种自然的发展趋势是不断提升更多高级形式的静态和混合分析。基于诸如先决条件和后置条件的满足性以及随码证明等技术的软件证明已经在关键软件中开始得到采用 \[Souyris09\]。它们要求更多的努力和成本，然而，在某些案例中，它们被证明为在长期具有成本高效性：在 1/3 的应用中具有开发时间和成本方面的改进，而对于已部署的系统只需较少的修补甚至不需要修补 \[Woodcock09\]。

### 2.1.9 潜在影响的基本原理

最大的潜在影响可能在于避免了那些随着时间演进会被严重依赖的组件的成本。Heartbleed 漏洞是一个例子，关于较小的代码基具有过大的重要性：对于形式化方法的明智使用可能会在一上来就避免此问题。通常，诸如那些可以利用形式化方法制造的高质量软件可以被用于降低软件组件的长期维护和替换成本。不像物理系统那样发生磨损并且最终失效，软件系统只会在它们本身不正确，并且其瑕疵被诸如特定的输入序列或者组合等环境因素触发时才会失效 \[Woody14\]。

### 2.1.10 延伸阅读

* \[Armstrong14\] Robert C. Armstrong, Ratish J. Punnoose, Matthew H. Wong and Jackson R. Mayo, “Survey of Existing Tools for Formal Verification,” Sandia National Laboratories Report SAND2014-20533, December 2014. Available: [http://prod.sandia.gov/techlib/access-control.cgi/2014/1420533.pdf](http://prod.sandia.gov/techlib/access-control.cgi/2014/1420533.pdf) Accessed 12 October 2016.
* \[Chapman14\] Roderick Chapman and Florian Schanda, “Are We There Yet? 20 Years of Industrial Theorem Proving with SPARK,” in _Proc. Interactive Theorem Proving: 5th International Conference, ITP 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 14-17, 2014_. Gerwin Klein and Ruben Gamboa, Eds., _Lecture Notes in Computer Science_, Vol. 8558, Springer, 2014, pp. 17-26, [https://doi.org/10.1007/978-3-319-08970-6_2](https://doi.org/10.1007/978-3-319-08970-6_2).
* \[Voas16a\] Jeffrey Voas and Kim Schaffer, “Insights on Formal Methods in Cybersecurity," _IEEE Computer_, Vol. 49, Issue 5, May 2016, pp. 102–105, [https://doi.org/10.1109/MC.2016.131](https://doi.org/10.1109/MC.2016.131). 7 位形式化方法专家的立场.
* \[Voas16b\] Jeffrey Voas and Kim Schaffer, “What Happened to Formal Methods for Security?”, _IEEE Computer_, Vol. 49, Issue 8, August 2016, pp. 70-79, [https://doi.org/10.1109/MC.2016.228](https://doi.org/10.1109/MC.2016.228). 同上述 7 位专家的关于形式化方法的后续圆桌会议.
* \[Woodcock09\] Jim Woodcock, Peter Gorm Larsen, Juan Bicarregui and John Fitzgerald, “Formal Methods: Practice and Experience,” _ACM Computing Surveys_, Vol. 41, Issue 4, October 2009, pp. 1-36, [https://doi.org/10.1145/1592434.1592436](https://doi.org/10.1145/1592434.1592436).

## 2.2 系统层级的安全性

当软件被执行时，用于该运行着的软件的系统上下文定义了可用于该软件的资源、访问这些资源所需的 API，以及软件可以如何访问外部实体（以及被它们访问）。系统上下文的这些方面可能会强烈影响以下内容：软件包含漏洞的可能性（例如复杂或者有 bug 的 API 将会增加这种可能性）、攻击者利用漏洞的可能性（例如系统服务越容易从外部接触，这种可能性就越大），以及攻击可能具有的影响（例如，对于系统资源和具体任务成本的损害）。

长期以来，系统设计者的目标之一是设计出对于攻击具有抵抗力，并且对于程序和用户都能强制实施理想的安全策略的系统。自 1965 年开始的多任务信息与计算系统（Multics）\[Corbato65\] 结合了若干种理念（例如虚拟内存、多进程和内存段等）以实现一种计算工具，它能够保护信息以防止非授权访问。自 20 世纪 70 年代开始，若干种安全策略模型被引入以使得系统层级的安全责任形式化。在 1976 年，Bell-LaPadula（BLP）模型 \[Bell76\] 提供了关于保护分级信息的强制安全性的形式化表达：BLP 模型允许“高”（例如 SECRET（机密））进程访问“低”（例如 UNCLASSIFIED（未分级））信息以获得可用性，但是禁止“低”进程访问“高”信息。 Goguen 和 Meseguer 的无干扰模型解释了间接信息流，又称为隐秘信道 \[Goguen84\]。Biba 的完整性模型表述了关于完整性的强制安全性：它禁止可能是恶意（低完整性）的数据被高完整性的进程观察到，由此降低高完整性的进程和数据可能发生损坏的风险 \[Biba71\]。Boebert 和 Kain 的类型强制模型提供了一种基于表格的访问控制机制，它只允许数据被预先批准的程序转换 \[Boebert85\]。这些模型为理想的安全属性提供了必要的明确性，但是，在真实尺度的系统中使用这些模型为系统管理员带来了可用性的问题，并且这些模型的软件实现仍然包含可被利用的瑕疵。

在 1999 年，美国国防高级研究计划局（DARPA）启动了建立在这一理念之上的入侵容忍系统（ITS）项目，即系统可以被构建为能够继续运作，或者“容忍”哪怕是成功的攻击。随之而来的若干其他研究项目也基于此理念而构建 \[Tolerant07\]。由这些项目探索的基本概念包括具有冗余和多样化的组件的系统构造，它们不太可能被单一漏洞全部破坏、新的策略强制执行软件层的引入，以及用于自动恢复的诊断推理组件的应用。深入容错系统的 DARPA 研究意识到，从真实世界的系统中消除所有漏洞对于可预见的将来是不太可能实现的。这些研究展示了在红队测试中的实质性容忍（例如参见 \[Chong05\]），但是这些方法同样施加了显著的配置复杂度、降低的执行速度和显著增加的资源（CPU、内存等）要求。

最近的软硬件进展带来了这样的可能性，即开发出对于性能和成本都很高效的安全性强制执行和入侵容忍系统。这样的系统拥有抑制软件漏洞所能造成的危害的潜力。在硬件方面，低成本的多核处理器和系统芯片正在降低实现冗余度的成本。在与之互补的软件方面，新兴的架构结构正在带来新的机会以便将安全性和容错性构建到下一代系统中。在众多可能的结构中，两种看起来有前途的结构是操作系统容器和微服务。

### 2.2.1 操作系统容器

“容器是为了运行于其中的应用程序或者系统而隔离宿主的某些资源的对象。”\[LXC\] 从实质上讲，容器是一个非常轻量级的虚拟机，其资源（内存、硬盘和网络等）可以同宿主计算机或者其他容器进行非常灵活的共享。容器提供了独立计算机或者完整的虚拟机的某些隔离属性，但是，容器可以在商品级硬件上在几分之一秒的时间内启动。容器通常要求显著少于完整虚拟机的计算和存储资源。

基于容器的隔离可以明显减少软件漏洞的影响，如果隔离足够强。因此，获取关于容器基础设施组件（例如 Linux 内核中的控制组和名称空间）在面对恶意输入时是强壮的这一点的担保至关重要。容器用户需要对这些组件进行建模、分析、测试和验证以构建关于容器配置能够按照预期运作的担保。

尽管容器可以非常轻量和灵活，这种灵活性的代价是容器配置的复杂性，这决定了容器中的众多关键元素，诸如它如何共享其资源、它的网络栈如何配置、它的初始进程、它所能够使用的系统调用等等。尽管市场已经接受了支持共享容器配置的管理系统，诸如 Docker \[Docker16\]，仍然需要这样的工具和技术，它们可以分析容器配置并且确定它们能够在多大程度上降低安全风险，包括能够在多大程度上化解软件漏洞的效果。

此外，容器带来了机会以应用某些传统安全性模型以及入侵容忍技术，利用有利于效率和部署的简易度的构建块。现在有了新的机会以重新评估哪些高级安全性模型和入侵容忍技术能够成为主流技术。

更进一步地，由于容器可以围绕某个程序的单次运行而有效地封包起来，容器可以被配置为仅仅授予某个程序对资源的最小访问级别，并且由此遵守最小权限原则 \[Saltzer75\]。最小权限原则是关于限制软件漏洞和攻击的效果的基本原则。然而，想要具体说明某个程序所要求的最小资源这一点是众所周知地困难的。与其试图在其完整的普遍性之中求解该问题，不如采用某种策略以开发分析技术和工具，以便生成自定义的容器配置，该配置能够近似重要程序类别的最小权限。由于部署容器的相对简易性，这样的工具辅助容器能够为主流系统带来显著增加的访问控制有效性和安全性。

### 2.2.2 微服务

微服务描述了“一种将软件作为一套小型服务来设计的方式，每个服务运行于其自身的进程之中，并且通过轻量级的机制进行通讯。”\[Fowler14\] 核心的微服务理念并非最新的：它已经被人们利用网络服务以及在基于微内核的操作系统中探索过了。这些方法包括 Mach 微内核 \[Rashid86\]、GNU Hurd \[Hurd16\]，以及网络服务架构 \[WSA04\]。然而，微服务方法根据不同的判据来构造服务。微服务应该实现单个业务（或者任务）能力、拥有独立的刷新循环、替换起来相对简单，并且对于编程语言不可知 \[Fowler14\]。简而言之，每一个微服务都应该具有其自身的经济和管理意义。与此同时，微服务可能彼此依赖，这可以支持具有良好定义的模块性。

这种系统结构方式可能产生若干组件，其接口被显式定义，并且其依赖也被类似地显式定义。

随着系统运行以及控制流在微服务之间传递，有一种自然而然的激励以使得服务间通讯“批量化”，从而分担跨边界的开销。尽管这种批量化在某些情况下可能会增加延迟，它也能够简化组件间依赖，并且可能减少发生软件瑕疵的可能性，进而减少漏洞。

将软件作为微服务的集合来部署带来了一个基本问题：构建一种“可信微服务”是否有意义？更加具有雄心壮志的问题是，开发出能够作为其自身的引用监视器的微服务是否可行？引用服务器的概念始于 1972 年的 Anderson 报告 \[Anderson72\]，并且指的是一种系统组件，它对于其所提供的资源的所有访问进行调度。引用监视器具有以下特点：1) 总是被调用；2) 防破坏；以及 3) 经过验证（即它足够小，以便被构建为具有高度担保）。随着微服务变得越来越流行，现在可能正是时机以研究制定关于可信的或是能够作为引用监视器的微服务的判据，以及理解微服务的架构结构的安全局限性。

通过使得组件依赖和相互作用更加显式化，微服务看起来带来了新的机会以实施基于干涉的安全增强。插入到这些微服务相互作用之间的封包层将会拥有能力以增强、转换、拒绝以及监视这些相互作用。这些能力可以被用于限制来自软件漏洞的潜在危害，但是，干涉也可能导致系统不稳定并且带来性能下降。一种可能的研究介入是调查与基于微服务的系统兼容的干涉策略。微服务提倡组件之间的简化接口（例如没有通过全局状态的内存共享）。这种简化可能使得基于微服务的干涉在执行时具有较少的与稳定性相关联的效果。

### 2.2.3 成熟度水平

虚拟化系统可以追溯至 20 世纪 60 年代。LXC 容器形式的虚拟化始于 2008 年，并且自此处于活跃开发之中。也存在若干替代的轻量级虚拟化系统，例如 BSD Jails、OpenVZ 以及 Oracle Solaris Zones。容器已经被实质性地部署于云端和服务器上。\[脚注 1\]

当前的微服务术语和设计目标出现于 2014 年。早期的表述方式，诸如运行于微内核之上的任务，可以追溯至创始于 1985 年的卡内基梅隆大学的 Mach 项目。自此以后，微内核技术成为了后续研究的主题，并且被整合进了大型商业产品，尤其是苹果 OS X。

> \[脚注 1\] 操作系统容器有助于实现某些云机制，但是云计算完全不同于操作系统容器 \[Mell11\]。

### 2.2.4 可信度的基础

基本技术已经被广泛应用，并且对于容器配置的更多自动化有着公认的需求，因此会有需求拉动。由于容器可以被非常快速地创建、测试和删除，已有确凿的证据显示关于容器配置的大范围测试可以通过半自动的方式进行。关于微服务，微服务框架的数量的增长提示该技术的流行度正在增加，并且仍然有空间以进一步丰富微服务框架，以及使得这些新增的框架被采用。同时，微服务的模块化本质可能为部署更多安全版本的微服务而不会显著干扰对用户的服务提供道路。

### 2.2.5 潜在影响的基本原理

操作系统容器和微服务已经是国家信息基础设施的重要组成部分。鉴于使用它们所具有的明确的可管理性、成本以及性能方面的优势，有理由期待它们的应用持续扩展。这些技术的安全增强版本一经采用，可以对软件漏洞的利用行为产生广泛的抑制效果。

### 2.2.6 延伸阅读

* \[Fowler14\] Martin Fowler, “Microservices: a definition of this new architectural term,” 25 March 2014. Available: [http://martinfowler.com/articles/microservices.html](http://martinfowler.com/articles/microservices.html) Accessed 13 October 2016.
* \[Lemon13\] Lemon, “Getting Started with LXC on an Ubuntu 13.04 VPS,” 6 August 2013. Available: [https://www.digitalocean.com/community/tutorials/getting-started-with-lxc-on-an-ubuntu-13-04-vps](https://www.digitalocean.com/community/tutorials/getting-started-with-lxc-on-an-ubuntu-13-04-vps) Accessed 13 October 2016.
* \[What\] “What’s LXC?”, Available: [https://linuxcontainers.org/lxc/introduction](https://linuxcontainers.org/lxc/introduction) Accessed 13 October 2016.

## 2.3 **未完待续**

