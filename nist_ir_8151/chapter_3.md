# 第 3 章 测定和度量

本章在最宽泛的意义上处理测定、评估、度量、鉴定、判断、评价等。因此，代码审查、软件测试和其他技术在本章中具有一席之地。如同我们接下来所讨论的那样，缺少经过精确定义和严格验证的测定方法，更糟的是，大多数现存的测定方法对于我们想要在软件中确定的高级属性而言只有中等程度的预测性。甚至没有广泛和详细的数据，诸如漏洞的数量和类型，以使得测定研究可以基于它们进行。

我们有 3 个关注的领域。其一，鼓励使用测定。世界上的所有非常规测定方法如果无人使用它们，就不会带来任何帮助。同样，无人 _可以_ 采取测定行动，如果该测定方法并未被制造出来因而成为可用。美国联邦政府可以促进并且鼓励使用软件产品测定。其载体包括采购、合同、责任、保险以及标准，如同 4.3 节所解释的那样。测定带来的好处将会被放大，如果它们在受到训练的软件开发过程中被修订、解读和使用 \[Curtis16\]。确实，良好的测定方法的广泛使用是少数方式之一，这些方式具有打破崩溃——补丁的轮回以及超越攻击者的潜力 \[Grigg08\]。软件也会得益于第三方、非政府组织的程序和判据。某些可能性包括 UL 网络安全担保计划（CAP）、信息科技软件质量联盟（CISQ）的代码质量标准、Coverity 扫描、核心基础设施倡议（CII）的最佳实践徽章，以及在成熟度模型中构建安全性（BSIMM）等。这些中的很多包括进程测定，这是第二个关注的领域。

第二个领域，进程测定，包括努力的小时数、更改的数量，以及在送达的代码中没有验收测试缺陷以及验收测试缺陷密度 \[Perini16\]。这些对于漏洞数量并没有直接影响，但是其间接影响巨大。例如，如果开发者被强迫频繁超时工作以赶上某个期限，或者计划安排不允许培训，则漏洞的数量很可能会显著增加 \[Perini16\]。其他范例包括指示新的过程步骤相对于先前的实践能够带来多少帮助的测定，或者指示过程中的允许漏洞逃逸的部分的测定。这种持续改进过程的方法被发现于最高等级的成熟度模型中。它还允许小组采用或者适应于对于他们的环境最为适用的方法和测定。我们不再进一步讨论进程测定。

最后一个关注的领域是对作为产品的软件的测定，例如，关于不存在缓冲区溢出的证明、每 1000 行代码中的缺陷数量、关于规范被满足的担保，以及通过测试套件实现的路径覆盖率等。美国国家标准技术研究所（NIST）的软件质量小组组织了一次关于用于减少安全漏洞的软件测定和度量（SwMM-RSV）的研讨会以征集想法，关于美国联邦政府可以如何最好地识别、改进、打包、带来或者提升软件测定方法的使用以显著减少漏洞 \[脚注 2\]。他们召集了简短的状态报告书，随后邀请了基于所提交的 20 个状态报告中的 10 个的研讨会演示。此研讨会举行于 2016 年七月 12 日，完整的研讨会报告可以作为 NIST SP 500-320 而获得 \[Black16\]。本章的大部分内容来自于此研讨会的成果。想法通常由一人提出，由其他人讨论和详细叙述，然后由另一些人编写并且报告。因此，在大多数情况下难于将想法署名给特定的个人。我们感谢参与了此研讨会并且对报告中所注释的想法作出了贡献的所有人，无论贡献大小。

> \[脚注 2\] 其网站为 [https://samate.nist.gov/SwMM-RSV2016.html](https://samate.nist.gov/SwMM-RSV2016.html)。

我们区分基本测定和导出测定。基本测定是具有明确的值的简单、基本的评估或者计数。与之相反，导出测定是“两个或者更多的基本测定的值的函数”\[ISO15939\]，或者是某个基本测定的数学变换 \[ISO25040\]。导出测定通常是那些我们想要能够测定的属性的替代品。例如，缓冲区溢出（BOF 类）\[Bojanova16\] 弱点的数量是一种具有合理地清晰的定义的基本测定。与之相反，代码安全性是一种导出测定，它只能微弱地通过 BOF 数量进行预测。缺陷的不存在并不指示着卓越的存在。

## 3.1 软件测定分类法

软件测定可以从 4 个维度来分类。第 1 个维度是该测定方法有多么“高级”。低级测定是语义之下的，诸如程序的大小、路径的数量和函数的扇入/扇出等。高级测定方法更多地处理的是程序的本意是要实现什么。第 2 个维度是静态还是动态。静态测定是那些应用于源代码或者“二进制文件”本身的测定方法。动态测定应用于程序的执行。第 3 种维度是视点。可以是外部视点，有时称为黑盒或者功能性的，或者是内部视点，在此代码被考虑，称为白盒（“清晰”或者“透明”）或者结构性的。第 4 个维度是测定的对象：bug、代码质量和一致性。

对于第 1 个维度，测定方法可以分为低级或者高级的。低级测定方法被广泛使用。与之相反，高级测定方法所处理的是作为客体的程序与作为有意识的主体的开发者或者用户之间的关系。质量在这种客体和主体的相互作用之中得到提升 \[Pirsig74\]。与低级和高级测定方法形成类比的是低级漏洞和高级漏洞。某些低级漏洞包括缓冲区溢出、整数溢出和未能提供默认的 switch 语句的 case 等。这些低级漏洞可以直接从代码中识别出来，即某人可以检视代码，或者使用某个程序来检视代码，并且确定对于给定的特定输入是否有可能出现 BOF。无需引用某种规范、要求或者安全策略来确定缓冲区溢出是否为可能。

另一方面，高级漏洞不能仅仅依靠参考代码而被识别出来。人类审查者或者静态分析器必须查询要求、规范或者策略以确定高级问题。例如，未能加密敏感信息通常不能完全通过代码检查而被识别出来。当然，启发式搜索是可能的。例如，如果某个变量被命名为“password”，静态分析器如此猜测是合理的，即该变量是某个口令并且不应该在没有保护的情况下被传输，也不应该可以被非授权用户访问。然而，不论工具还是人类都不能在不对其进行外部定义的检查的情况下确定某个被命名为“ID”的变量中的信息是否应该被加密。

拥有对于安全策略和要求文档的访问并不会使得软件质量在所有案例中被评估。要求文档通常应对的是程序的行为，以及程序特有地需要去做什么。形式化地指定该代码应该是高质量的这一点是困难的，也许完全不可能。软件架构是定义结构组成的一种方式，它将良好的、有用的软件同易出错的、难于调试的、脆弱的或者不灵活的软件区分开来。

对测定方法进行分类的第 2 个维度——静态还是动态——在测试中最为明显。测试测定在概念上有两部分：测试生成或者选择，以及测试结果评价。测试测定通常回答这样一个问题，即程序（内部）或者输入空间（外部）有多少被使用了？测试案例生成必然是静态的，而评价通常是动态的，即基于执行结果。在众多测试测定中，这两部分彼此联结。它们可能包括某个例如选择额外的测试案例以增加覆盖率的步骤。因此，动态部分会影响静态部分。测试通常被引用为动态技术，由于程序执行是测试的重要组成部分。即如果某人提出了测试案例 _但是从未运行它们_，则严格地说不会得到任何担保。当然，在大多数案例中，选择测试案例过程中的思考和检查是一种静态分析，它产出了关于程序的某些担保。ISO/IEC 25023 将静态测定引用为内部测定，而将动态测定引用为外部测定 \[ISO25023\]。

第 3 个维度是视点，可以是外部或者内部的。外部测定通常是关于规范、要求或者限制的行为一致性。它们基于软件被观测到做了什么。它们通常被引用为“黑盒”或者行为性的。这些测定方法对于验收测试以及估计用户或者任务满意度极为有用。如果程序不能满足其目的，该程序编写得多么好或者其内部结构组织得多么好几乎没有任何意义。与之相反，内部或者结构性测定主要应对的是代码的架构、实现以及精细粒度操作，或者得到关于它们的信息。内部测定基于对源代码或者可执行文件的分析。此类测定方法与质量相关，诸如可维护性、可移植性、优雅性和潜力等。例如，外部计时测试可能不足以确定算法的复杂度，而代码检查可以清楚地显示该算法的复杂度为 Θ(_n_<sup>2</sup>)，并且对于较大的输入会有性能问题。

确定多少测试才是足够的同样展示了内部和外部测定的区别。外部测定，诸如边值分析 \[Beizer90\] 和合并测试 \[Kuhn10\]，考虑行为或者规范以计算已经测试了多少，或者还有什么尚未测试。另一方面，内部测定包括区块数量计数、变化充分性 \[Okun04\] 以及覆盖率测定 \[Zhu97\] 等。这两种方式是互补的。基于外部的测试可以发现缺失的特性，基于内部的测试可以提出从要求来看并不清楚的案例，例如，当存在众多项目时由插入排序切换到快速排序。

对测定方法进行分类的第 4 个维度在概念上将其分为 3 类。第 1 类测定是存在（或者不存在）特定的弱点，诸如缓冲区溢出（BOF 类）或者注入（INJ 类）\[Bojanova16\]。注意，瑕疵的不存在并不指示例如弹性架构等。第 2 类是质量测定，其本意是确定代码或者部分代码的优秀性，然而，我们仅仅拥有“质量”的代理，例如可维护性、可移植性以及断言的存在等。即使如此，这些代理中的很多只能间接估计。前两类是关于产品质量的特征 \[ISO25010\]。第 3 类是与规范的一致性或者正确性。这第 3 种测定用于使用特征中的质量 \[ISO25010\] 并且必须具体到每一项任务。有可用的通用要求语言和检查方法。由于这 3 种类别之间的深刻差别，没有一种安全性或者漏洞测定方法可以保证优秀代码。

## 3.2 软件担保：软件测定的目标

关于软件将会按照其所应该的方式发挥功能的担保有 3 个来源。其一是开发过程，如果软件由拥有明确要求、经过良好培训并且已经被证明能够构建具有低漏洞率的良好软件的团队开发，那么我们就能够拥有关于他们所生产的软件很可能具有极少漏洞的信心或者担保。担保的第 2 个来源是我们对于软件的分析。例如，代码审查、验收测试和静态分析等可以为我们保证该软件的漏洞很可能是稀少的。我们可以牺牲这两种资源以换取担保。如果我们几乎没有任何关于开发进程的信息，或者该开发进程在过去并未产出良好的软件，我们必须进行多得多的分析和测试以获取关于软件质量的信心。与之相反，如果我们对于开发团队和开发过程拥有信心，我们只需进行最小化的测试以确保该软件能够遵循过去的经验。

软件担保的第 3 个来源是弹性执行环境。如果我们对于软件质量没有信心，那么我们可以在容器中运行它，如同 2.2.1 节所解释，给它极少的系统权限，并且让其他程序监视其执行。如果任何漏洞被触发，则它对系统的危害是受到控制的。

我们可以利用数学公式来表达我们的担保：_A_ = _f_(_p_, _s_, _e_)，其中 _A_ 为我们所拥有的担保的量，_p_ 为来自我们关于其进程的知识的担保，_s_ 为来自静态和动态分析的担保，而 _e_ 为我们通过严格执行环境所获得的担保。合并函数 _f_ 为某种加和运算，类似于 _p_ + _s_ + _e_。如同我们之前所述，如果我们没有关于进程的信息，则可以通过额外的分析工作来提升我们的总体担保。另一方面，如果我们对于开发软件的进程（和人）拥有巨大信息，则我们不需要进行那么多的分析工作。

## 3.3 软件计量学

为了拥有一种合乎逻辑的、广泛有用的测定系统，某人必须拥有坚实的理论基础，即软件测定的哲学。这种哲学必须拥有坚实的数学基础，例如，以使用合理的统计 \[Böhme08\]。本节解决了诸如这样的问题，即什么是软件计量学？它的目的是什么？相对于物理测定，测定软件过程中所特有的挑战是什么？可能的解决方案或者潜在的方法是什么？

软件测定方法拥有众所周知的理论局限性，与物理学中的海森堡不确定性原理相类比，计算机科学拥有停机问题、莱斯定理，及其相关结果，它们展示了正确地确定 _所有_ 可能的程序的感兴趣的测定结果是不可能的。尽管这是一种提醒，这并不意味着所有有用、精确、准确的测定都是不可能的。有若干种方式以避免这些理论障碍。其一，我们可以满足于相对属性。能够确定某个程序的新版本相对于之前的版本更加安全（或者不那么安全！）可能会有所帮助。我们并不需要关于某个程序的安全性的绝对测定结果。其二，某项测定可能仅适用于拥有“合理的”结构的程序。某项测定仍然会有用，即使它不适用于那些完全由数以百万计的散布着变幻莫测的计算的条件的 go-to 语句构成的程序。无人（应该）编写这样的程序。最后，社会可以就特定应用程序作出决定，而我们只需要构建可测定的软件。民用建筑师不会被允许设计具有随意的拱门、穹顶、悬臂和正面的建筑。他们会被要求运行分析以展示该设计能够承受预期的负载和力，然后建设才能开始。当前，大多数程序员学习编写“优雅”软件，然后试图展示它能够工作。期望可能会发生更改，以使得专业人士只会编写那些能够明确满足其限制和要求的软件。

计算机程序员有时会半严肃地使用片语“这不是 bug：这是特性”。它强调了 bug 和特性是在某种意义上相互关联的实体。让我们假设某个程序可以被表征为一系列特性。（程序是一系列特性这一理念是某些大小测定的基础。例如，函数点测定试图捕获某个基本操作或者功能的理念。）称某个程序“有一个 bug”意味着它是某个“良好”程序的有 bug 的版本。良好的程序和有 bug 的程序都是程序。根据这一假设，两个程序都是一系列特性。因此，良好的程序和有 bug 的程序之间的区别在于某些特性的集合——添加、移除或者更改的特性。因此，精确的定义是：bug 是理想的特性和现存的特性之间的区别。在众多案例中，一个 bug 可能只是某个额外的特性，或者是取代另一个特性的特性。

我们可能会将软件计量学和物理计量学对立起来。在物理计量学中，挑战在于精确并且可重现地确定物理对象、事件或者体系的属性。与之相反，对于软件，大多数所谓的测定只是计数。一个恰当的案例是，ASCMM-MNT-7：模块间依赖循环拥有精确定义 \[OMG16\]。不难编写这样一个程序以精确测定实例数，在此，某个模块拥有循环回某个软件的引用。这样，差别就在于物理计量学已经明确标识出了他们想要确定的属性，例如质量、长度、时间和温度等。与之相反，软件计量学拥有一道完全不同的鸿沟。我们想要测定高级属性，诸如质量、可维护性和安全性等，但是我们并没有关于这些的精确定义。因此，我们不能直接测定它们。然而，我们可以测定与这些高级属性相关联的众多属性。

当前，计量学将实体数量计数降级为一种用于确定属性的第二类方法。这样的经过计数的 _量_ 全部被视为相同的一维的量，有时被称为无量纲量，尽管它们可能具有不同的 _类型_。

## 3.4 产品测定

如同良好的进程对于生产具有极少漏洞的代码至关重要那样，终极能力是测定代码本身。如同本章绪言所指出的那样，对软件本身的测定可以为进程改进提供信息。

安全性或者漏洞测定在其最宽泛的意义上包括测试和检查。我们需要这样的测定以确定此报告中的目标是否实现！采用此报告中给出的任何一种技术可能不会显著减少漏洞。未能实现减少漏洞可能只是由于关于技术如何使用的某些细节问题，或者可能是由于该技术就是不适用。如果采用了若干种技术，区分每一种技术的效果或者其共同效果甚至会变得更难。

这样的测定不能被留到开发的最终阶段才进行。它们必须被包括到软件开发的 _所有_ 阶段。除了像净室方式 \[Mills87\] 这样的充满雄心壮志的方法以外，此类测定不能作为门而被留到接近开发周期的结束。

有这样的可能性，即软件质量和安全性测定对于减少软件漏洞而言可能是错误的重点。某些测定可能会渐渐显露为重点，由于其他测定方法可能具有内聚性以及麦凯布循环复杂度。也可能证实最佳方式就像净室，在此，测定方法告知一种决定，以接受或者拒绝，并且不会宣称其创建了关于没有错误的绝对认证。

### 3.4.1 现存的测定方法

有数以百计的被提议的软件测定方法，诸如代码行数、类耦合性、封闭类的数量、函数点、更改密度，以及内聚性等。它们中的大多数并未经过精确定义或者严格验证。更糟的是，它们中的大多数对于软件中的我们所希望确定的高级属性只是具有中等程度的预测性。例如，代码行数（LoC）只是捕获了程序能力中的某些方差。同一规范在同一语言中的 LoC 可能相差多达 4 倍，即使所有程序员都拥有相近的技能。另一方面，LoC 与程序中的 bug 具有显著的强相关性。（这提示高级语言和领域特定语言一般会产生较少的 bug，由于它允许程序员更加精炼地表达功能。）

有些事情即使看起来就像在程序中数 bug 那样简单，其实也是令人惊讶地复杂的 \[Black11b\]。哪怕只是主观地定义什么是 bug 也很难。例如，某人可以编写一段永远不会发生整数溢出的二分搜索算法，但是该代码难于理解。除以零可能拥有良好定义的行为，得到特殊值“非数”，但是这通常不是一种有用的结果。bug 通常是若干种困难的级联反应。假设 (1) 未经检查的用户输入导致 (2) 整数溢出，进而导致 (3) 正在被分配的缓冲太小，进而导致 (4) 缓冲区溢出，最终导致 (5) 信息泄露。我们应该将此计为 1 个还是 5 个 bug？如果程序员在若干位置犯了同一个系统性的错误，例如未能在使用资源之后将其释放，这是一个问题还是若干个问题？与其说是例外，这些复杂性不如说是软件的规则 \[Okun08\]。

对于任何现实的程序，测试每一种可能的输入是不可行的。与之相反，必须选择一种测定方法以跨越整个空间。这些测定方法包括输入空间的合并覆盖 \[Kuhn13\]、变化充分性 \[Okun04\]、路径覆盖率测定 \[Zhu97\] 和边值分析 \[Beizer90\] 等。这些测定方法相互关联。例如，某些级别的（静态）合并覆盖能够制造那些产生了完整分支覆盖的测试，即一种动态测定方法 \[Kuhn15\]。

有太多的被提议的测定方法难于评估，甚至哪怕只是在这里列出来。我们可以说，如同上文所暗示，测定方法应该紧密地基于良好建立的自然科学，并且拥有合理的计量学基础，以获得最大的实用性 \[Flater16\]。

### 3.4.2 更好的代码

用于减少安全漏洞的软件测定和度量（SwMM-RSV）研讨会上的两则演示，Andrew Walenstein 的“测定软件的可分析性”和 James Kupsch 的“应对对于静态分析不透明的代码”指出了新的软件测定方法的方向。两则演示都强调代码应该能够被自动分析。两则演示都呈现了方法以定义代码能够被容易地分析这一点意味着什么、为何可分析性对减少漏洞有贡献，以及可分析性可以如何被测定和增强。

编程语言的部分子集被设计为可分析的，诸如 SPARK，或者被设计为不那么容易出错的，诸如 Less Hatton 的 SaferC。研讨会参与者普遍倾向于使用更好的语言，例如，函数式语言，诸如 F# 或者 ML。然而，对于未来并没有特别建议的 _某种_ 语言。

我们注意到，除了少数特例，诸如拥有 SPARK 的 Ada 2012 \[Barnes13\] 以外，其他新语言的工具支持欠佳。支持新工具的构建对于新语言的采用和安全使用至关重要。

尽管基于代码的测定方法是重要的，我们可以期待从对于软件的其他方面的测定中得到互补的结果。某些方面包括软件架构和设计侵蚀测定、代码的语言方面、开发者的背景，以及与软件要求相关联的测定方法等。

### 3.4.3 二进制文件和可执行文件的测定方法

某些研讨会参与者认为，存在着对于二进制文件和可执行文件的测定方法的显著需求。由于有了今天的优化编译器以及对于二进制文件中带来的众多库的依赖，仅仅检查源代码为所有类型的漏洞的出现留下了通到。

### 3.4.4 更加有用的工具输出

今天，有众多强大并且有用的软件担保工具可用。没有单一的工具能够满足所有需求。因此，用户应该使用若干种工具。这是困难的，由于工具拥有不同的输出格式，并且使用不同的术语和类。工具输出应该被标准化。即通用的命名法、呈现形式和细节越多，用户就越有可能将工具的结果和其他软件担保信息合并起来，并且选择一种对他们最为有利的工具组合。

此外，工具可以提供关于它们的分析的更多信息。工具可以指示哪部分代码已经被完整地检查，而哪部分还没有，例如由于复杂度或者启发式搜索等。这类检查信息可以被附加到代码，使其成为“随码担保”\[Woody16\]，与随码证明相类比。

参与者们感受到了对于科学地有效的研究的需求，研究内容包括工具的强度和限制、允许公开第三方对于工具的评估的机制、分享关于工具的洞察力的通用论坛，可能甚至还有关于经过验证或者认证的工具的列表。

## 3.5 延伸阅读

* \[Barritt16\] Keith Barritt, “3 Lessons: FDA/FTC Enforcement Against Mobile Medical Apps,” 14 January 2016. Available: [http://www.meddeviceonline.com/doc/lessons-fda-ftc-enforcement/against-mobile-medical-apps-0001](http://www.meddeviceonline.com/doc/lessons-fda-ftc-enforcement/against-mobile-medical-apps-0001) Accessed 12 October 2016.
* \[FTC16\] Federal Trade Commission, “Mobile Health App Developers: FTC Best Practices,” April 2016. Available: [http://www.ftc.gov/tips-advice/business-center/guidance/mobile-health-app-developers-ftc-best-practices](http://www.ftc.gov/tips-advice/business-center/guidance/mobile-health-app-developers-ftc-best-practices) Accessed 13 October 2016.
* \[Perini16\] Barti Perini, Stephen Shook and Girish Seshagiri, “Reducing Software Vulnerabilities – The Number One Goal for Every Software Development Organization, Team, and Individual,” ISHIPI Technical Report, 22 July 2016.

